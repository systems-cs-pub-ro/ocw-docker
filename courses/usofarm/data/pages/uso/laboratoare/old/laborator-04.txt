~~SHOWSOLUTION~~
====== Laborator 04 - Utilizatori și procese ======

===== Cheatsheet utilizatori =====

^ Comandă  ^ Descriere scurtă       ^
| **''sudo''**     | execută o comandă cu drepturi de utilizator privilegiat |
| **''su''**       | schimbă utilizatorul cu care suntem autentificați       |
| **''id''**       | afișează id-ul și grupurile din care face parte un utilizator |
| **''finger''**   | afișează un sumar despre un anumit utilizator |
| **''whoami''**   | afișează utilizatorul curent (cu care suntem autentificați) |
| **''who''**      | lista de utilizatori autentificați la un moment dat |
| **''passwd''**   | schimbă parola unui utilizator | 
| **''adduser''**  | adaugă un utilizator |
| **''deluser''**  | șterge un utilizator |
| **''usermod''**  | modifică informații despre un utilizator (exemplu: grupul din care face parte) |
| **''addgroup''** | adaugă un grup de utilizatori |
| **''delgroup''** | șterge un grup de utilizatori |
===== Cheatsheet procese =====

^ Comandă  ^ Descriere scurtă  ^
| **''ps''** | snapshot al proceselor curente                                             |
| **''pgrep''** | Afișează PID-ul proceselor cu nume dat ca argument. Se pot folosi opțiuni pentru filtrare (exemplu: după numele utilizatorului care a deschis respectivul proces) |
| **''top''** | utilitar echivalent lui Windows Task Manager, in Linux. Există și **''htop''**, mai avansat și cu mai multe posibilități |
| **''pstree''** | ierarhia de procese                                             |                                          |
| **''kill''** | trimite un semnal unui proces. Folosind comanda **''kill -l''** putem vedea semnalele care pot fi trimise |
| **''killall''** | omoară toate procesele cu același nume |
| **''pkill''**  | caută un proces după nume și îi transmite un semnal             |
| **''jobs''** | afișează procesele pornite în background |

==== Foreground and background procese ====

{{:uso:laboratoare:foreback.gif|}}

==== Stările unui proces ==== 

{{:uso:laboratoare:process-states.png?600|}}




===== Suport laborator =====

  * [[http://books.google.com/books?id=_JFGzyRxQGcC&pg=PA53| 3. Gestiunea pachetelor și utilizatorilor]]
  * [[http://books.google.com/books?id=_JFGzyRxQGcC&pg=PA111|5. Procese]]
  * [[http://cb.vu/unixtoolbox.xhtml#processes|Unix Toolbox - Processes]]
  * [[http://xkcd.com/619/|Support for more than 1024 CPUs]]

====== Demo ======

===== Utilizatori =====

==== [1] Utiliatori privilegiați si neprivilegiați (id, finger, whoami) ====

În general, pe un sistem Linux, sunt două ierarhii de utilizatori:
  * neprivilegiați  - nu pot modifica starea sistemului, nu pot realiza modificări ce afectează alți utilizatori
  * privilegiați - spre exemplu utilizatorul ''root''

Utilizatorul root este prezent, în general, pe orice sistem Linux, rolul său fiind de administrare și gestionarea celorlalți utilizatori.

<note warning>
Nu este recomandat să folosiți sistemul folosind acest utilizator decât pentru strictul necesar. De multe ori este suficientă utilizarea comenzii ''sudo''.
</note>

<hidden>
Întrebați-i pe ei ce cred despre asta și apoi explicați-le ce riscuri implică //abuzarea// de utilizatorul ''root'' (rularea GUI-ului ca ''root'', de exemplu).

Pentru a oferi totuși câteva drepturi minimale anumitor utilizatori, se folosește comanda ''sudo'' (**S**uper **U**ser **DO**). Ea are rolul de a //lăsa// un utilizator să ruleze o comandă ca și cum ar fi autentificat ca un altul (nu neapărat ''root'').

În continuare, vom vedea cum aflăm câteva informații despre utilizatori și cum ne schimbăm utilizatorul cu care suntem autentificați:

Le arătăm câteva detalii despre utilizatorul ''student'' și despre ''root''. Să vedem că există, în principal, dar pomeniți-le și de home directory, shell etc. Sugerez să folosim comanda ''finger''.

<note warning>
S-ar putea să nu fie instalată: ''sudo apt-get install finger''
</note>

<code bash>
student@midgard:~$ finger student
Login: student        			Name: Flavius Anton
Directory: /home/student            	Shell: /bin/bash
On since Sat Oct 25 17:16 (EEST) on :0 from :0 (messages off)
On since Sat Oct 25 17:18 (EEST) on pts/0 from tiny
   3 seconds idle
No mail.
No Plan.
student@midgard:~$ finger root
Login: root           			Name: root
Directory: /root                    	Shell: /bin/bash
Never logged in.
No mail.
No Plan.
</code>

Le spunem apoi că o altă metodă pentru a verifica cu ce utilizator suntem autentificați (în afară de a ne uita la prompt) este comanda ''whoami''

<code bash>
student@midgard:~$ whoami
student
</code>

Pentru a le arăta un use-case concret, puteți modifica temporar variabila ''PS1'', ca mai jos.

<note info>
Cu siguranță ei vor avea o reacție de genul "What kind of sorcery is this?", dar le puteți spune că e doar o variabilă de mediu și că vor învăța puțin mai târziu ce sunt ele. Pentru moment, e ok să rețină că nu trebuie să se lase păcăliți de către prompt. 
</note>

<code bash>
student@midgard:~$ PS1="Obama@Whitehouse# "
Obama@Whitehouse# whoami
student
</code>

</hidden>

==== [2] Schimbarea utilizatorului curent (su) ====
Câteodată este necesar să schimbăm utilizatorul cu care suntem autentificați într-un altul (de exemplu în ''root'' pentru a realiza un task administrativ). Pentru aceasta folosim comanda ''su'' (switch user). Haideți să vedem cum o folosim.

<hidden>
<note info>
Creați înainte de demo un utilizator dummy, ''ana''.
</note>

<code bash>
student@midgard:~$ whoami
student
student@midgard:~$ su ana
Password: 
ana@midgard:/home/student$ whoami
ana
</code>

Dați și un ''ls -l'' pe directorul ''home'', să vadă că fiecare are propriul director ''home''.


<code bash>
student@midgard:~$ ls -l /home
total 8
drwxr-xr-x  2 ana     ana     4096 Oct 25 17:43 ana
drwxr-xr-x 15 student student 4096 Oct 25 17:17 student
</code> 

Spuneți-le de opțiunea ''-'' (sau ''-l''), a comenzii ''su'', pentru a schimba întregul context, nu doar utilizatorul.

<code bash>
student@midgard:~$ su - ana
Password: 
ana@midgard:~$ logout
student@midgard:~$ su ana
Password: 
ana@midgard:/home/student$ pwd
/home/student
ana@midgard:/home/student$ exit
student@midgard:~$ su - ana
Password: 
ana@midgard:~$ pwd
/home/ana
</code>

</hidden>
==== [3] Drepturi pentru anumite comenzi (sudo) ====
Să presupunem că pe un sistem avem 100 de utilizatori și vrem ca toți să aibă drepturile necesare instalării de noi pachete, dar să nu poată adăuga/șterge alți utilizatori. Pe lângă faptul că ar fi foarte foarte nesigur ca 100 de persoane să știe parola contului de ''root'', ar trebui să ne bazăm pe încrederea că ei nu vor face altceva decât să instaleze pachete. Soluția acestei probleme este comanda ''sudo''.

<hidden>
Hai să le arătăm încă o dată că nu putem instala pachete decât cu ''sudo'', în mod normal. Aratați-le că eroarea generată are legătură cu permisiunile utilizatorului, încercăm să-i obișnuim de fiecare dată să se uite pe mesajele de eroare (la mine, cel puțin, am observat că au problema asta: se sperie de wall of text la o eroare și nu mai citesc nimic, se blochează acolo).
<code bash>
student@midgard:~$ apt-get install cowsay
E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)
E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?
student@midgard:~$ sudo apt-get install cowsay
[sudo] password for student: 
Reading package lists... Done
...
student@midgard:~$ cowsay "Meuh"
 ______
< Meuh >
 ------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
</code>

== Opțional ==
<note>Dacă simțiți că demo-ul a durat prea mult până aici, puteți să nu le mai spuneți nimic de ''visudo''. Altfel, nu cred că ar strica să le arătăm cum îi dăm drepturi de ''sudo'' utilizatorului ''ana''.
</note>

<code bash>
ana@midgard:~$ sudo apt-get install tree
[sudo] password for ana: 
ana is not in the sudoers file.  This incident will be reported.

ana@midgard:~$ logout
student@midgard:~$ sudo visudo # adăugăm linia ana	ALL=(ALL:ALL) ALL

student@midgard:~$ su - ana
Password: 
ana@midgard:~$ sudo apt-get install tree
[sudo] password for ana: 
Reading package lists... Done
...
</code>

Putem face și un mic intro pentru laboratorul cu permisiuni și să le arătăm că fișierul ''/etc/sudoers'' este protejat.

<code bash>
student@midgard:~$ cat /etc/sudoers
cat: /etc/sudoers: Permission denied
student@midgard:~$ sudo cat /etc/sudoers
#
# This file MUST be edited with the 'visudo' command as root.
...
</code>

</hidden>

==== [4] Schimbarea parolei (passwd) ====
Pentru a schimba parola utilizatorului curent folosim comanda ''passwd'', fără argumente. De asemenea, dacă dorim schimbarea parolei altui utilizator, îi putem oferi comenzii ''passwd'' numele acestuia ca parametru. Mai departe vom vedea un exemplu de cum facem acest lucru.

<hidden>
Partea asta ar trebui să dureze 2-3 minute. Nu cred că are sens să le arătăm și alte opțiuni pentru ''passwd'' deocamdată.

<code bash>
student@midgard:~$ passwd
Changing password for student.
(current) UNIX password: 
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully

root@midgard:~# passwd student
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully
</code>
</hidden>

==== [5] Gestiunea utilizatorilor (adduser/deluser) ====
Acum că știm cum vedem informații despre un utilizator, cum schimbăm o parolă sau cum schimbăm utilizatorul curent, hai să vedem cum adăugăm utilizatori noi sau cum ștergem un utilizator dintre cei existenți. Pentru aceasta vom folosi comenzile ''adduser''
și ''deluser''.

<note important>
Cele două comenzi sunt de fapt niște scripturi ''wrapper'' scrise în [[https://www.perl.org|Perl]] prezente, în general, numai pe distribuții bazate pe [[http://www.debian.org|Debian]] (cum ar fi Ubuntu). Comenzile pe care le apelează ele în spate sunt ''useradd'' și ''userdel''.
</note>

<hidden>
Adăugăm un alt utilizator, ''bogdan''. E o ocazie bună să le spunem de ''uid'', de grupuri, de faptul că home-ul arată la început exact ca directorul ''/etc/skel'' etc.

<code bash>
student@midgard:~$ finger bogdan
finger: bogdan: no such user.

student@midgard:~$ sudo adduser bogdan
Adding user `bogdan' ...
Adding new group `bogdan' (1002) ...
Adding new user `bogdan' (1002) with group `bogdan' ...
Creating home directory `/home/bogdan' ...
Copying files from `/etc/skel' ...
Enter new UNIX password:
...
 
student@midgard:~$ finger bogdan
Login: bogdan         			Name: 
Directory: /home/bogdan             	Shell: /bin/bash
Never logged in.
</code>

După aceasta ne și autentificăm ca utilizatorul ''bogdan''.

<code bash>
student@midgard:~$ su - bogdan
Password: 
bogdan@midgard:~$ whoami
bogdan
</code>

În final, le arătăm și cum se șterge un utilizator:

<code bash>
student@midgard:~$ sudo deluser bogdan
Removing user `bogdan' ...
Warning: group `bogdan' has no more members.
Done.
student@midgard:~$ finger bogdan
finger: bogdan: no such user.
student@midgard:~$ su bogdan
No passwd entry for user 'bogdan'
</code>

</hidden>


==== [6] De reținut! ====

<note important>
La orice moment de timp, așa cum te uiți în oglinda retrovizoare a unei mașini și știi mereu ce ai în spate, trebuie să știi trei lucruri, mai ales în contextul folosirii mașinilor virtuale:

  * care este hostname-ul (pe ce sistem te afli). Comenzi utile: ''cat /etc/hostname'', ''hostname''
  * care este username-ul (cu ce utilizator ești autentificat): ''whoami'', ''id'' (fără parametri), 
  * care este working directory-ul (în ce director lucrezi): ''pwd''

Toate informațiile de mai sus se găsesc în prompt-ul terminalului: ''**username@hostname:working-directory**''.
</note>

<note tip>E important să reținem că urmărirea prompt-ului este o convenție. Acesta poate fi schimbat foare ușor folosind ''bashrc''. Detalii puteți găsi [[http://www.cyberciti.biz/tips/howto-linux-unix-bash-shell-setup-prompt.html|pe cyberciti]]. </note>

===== Procese =====

==== [1] Vizualizarea proceselor din sistem (ps, pstree, top, htop) ====

Ierarhia de procese în formă arborescentă putem vizualiza folosind ''pstree'' (similar cu ''tree'' de  la sistemul de fișiere)

Folosind ''ps'' fără nici un parametru vizualizăm procesele din shell-ul curent asociate utilizatorului curent. Tot cu ''ps'' putem vizualiza un ''snapshot'' al tuturor proceselor. Aceasta se poate obține folosind două variante ale comenzii:

<code bash>
student@midgard:~$ ps aux
student@midgard:~$ ps -ef
</code>

Un utilitar echivalent lui Windows Task Manager pentru vizualizarea în timp real a proceselor care rulează, în linie de comandă, este ''htop''. 

<code bash>
student@midgard:~$ htop
</code>

<hidden>
Vă rog să le reamintiți de la curs: 

  * noțiunea de proces
  * deosebirea între proces și executabil (deși se face la curs trebuie insistat)
  * ierarhia de procese (și dați și un **''pstree''** să vadă practic)

Trebuie să bage la cap următoarele întrebări de fiecare dată când depanează probleme de procese:

Ce vrem să monitorizăm?
  * Consum resurse cauzat de procesele pornite: CPU, RAM etc. 
  * Consum per utilizator (e.g.: ce utilizator folosește intensiv sistemul nostru și ce aplicații a pornit)
  * Ce fișiere ține un proces deschis (lsof, fuser, procfs)

Arătați-le pentru fiecare bullet cum pot face asta cu utilitarele disponibile în Linux. 
</hidden>



==== [2] Foreground & Background (&, fg, bg, jobs) ====

Porniți un proces ''sleep 1000'' (nu face nimic, e deschis, în starea ''sleep'' timp de 1000 de secunde). Haideți să le transmitem niște semnale prin combinații de taste, să vedem ce observăm în Bash. De exemplu:

^ Taste     ^ Semnificație                                              ^
| **''Ctrl+C''**     | trimite ''SIGINT''                           |
| **''Ctrl+Z''**     | trimite ''SIGSTOP''       |
| **''Ctrl+\''**    | trimite ''SIGQUIT''   |


<code bash>
student@midgard:~$ sleep 1000
^Z
[1]+  Stopped                 sleep 1000
student@midgard:~$ bg
[1]+ sleep 1000 &
student@midgard:~$ jobs
[1]-  Running                 sleep 1000 &
student@midgard:~$ fg 1
sleep 1000
^C
student@midgard:~$ 
student@midgard:~$ ps
  PID TTY          TIME CMD
13038 pts/0    00:00:00 bash
16827 pts/0    00:00:00 ps
</code> 

Creăm un proces care va rula mult timp (căutăm să aflăm dimensiunea tuturor fișierelor), apoi aducem în starea ''stopped'', apoi în ''running'', apoi ar trebui să apară și un Exit când termină. Cu ''jobs'' putem afla procesele ''running'' din fundal. Detalii aflați din ''help jobs'' :-)

<code bash>
student@midgard:~$ sudo du -hs /
[sudo] password for student:
^Z
[1]+  Stopped                 sudo du -hs /
student@midgard:~$ bg
[1]+ sudo du -hs / &
student@midgard:~$ jobs
[1]+  Running                 sudo du -hs /
student@midgard:~$ 3.4G   /
[1]+  Exit 1                  sudo du -hs /
</code>

<hidden>

<note tip>Puteți da un ''echo $!'', întrucât ''$!'' este PID-ul ultimului proces aflat în background. Detalii vor vedea la variabile speciale</note>

Acum pornim direct un proces tot așa de durată în background și apoi dăm un **''fg''** (preferabil și **''fg''** cu ID-ul job-ului să vadă și de această posibilitate de a aduce în foreground ce vrem noi). Precizați, totuși, că fără nici un parametru, **''fg''** aduce în ''foreground'' ultimul proces trimis în ''background'', ca în exemplul de mai jos:

<code bash>
student@midgard:~$ sudo find / -name '*' &
[1] 3127  # this means that our process is running!
student@midgard:~$ fg
sudo find / -name '*' > /dev/null 2>&1
</code>

</hidden>

==== [3] Semnale (kill)====

Un utilizator poate trimite un semnal unui proces folosind comanda ''kill''! Este foarte important să înțelegem că __nu__ este scopul principal omorârea de procese folosind ''kill''. O listă a tuturor semnalelor posibile ce pot fi trimise aflăm prin

<code bash>
student@midgard:~$ kill -l   
</code>

Noi ne vom concentra pe distrugerea proceselor, în următorul demo. 

Haideți să pornim un proces, în fundal, care caută toate fișierele în ''/'':

<code bash>
student@midgard:~$ find / -name '*' &
</code>

Deschidem un alt terminal. Căutăm identificatorul procesului anterior. Nu folosi ''top'', care e interactiv și ne afișază toate procesele în timp real, pentru că ne interesează doar procesul sau procesele de ''find'':

<code bash>
student@midgard:~$ pgrep find
2628
</code>

Pe sistemele voastre va varia PID-ul (Process ID). 

Ne dăm seama că procesul consumă resurse (operații pe hard disk) inutile. Dorim să îl terminăm:

<code bash>
student@midgard:~$ kill 2628
</code>

Implicit, kill trimite semnalul ''15) SIGTERM'': acesta se asigură că toate resursele folosite de proces (cum fișiere deschise) sunt închise corect și abia apoi e închisă aplicația (e omorât procesul). Semnalul ''9) SIGKILL'' e preocupat în principal de închiderea aplicației direct. Comanda de mai sus e similară cu 

<hidden>
Spuneți-le de diferența între ''SIGKILL'' și celelalte semnale, precum ''SIGTERM''. Ca să țină minte, repetați partea asta, dar într-un singur terminal, pornind procesele cu ''&''. Omorâți-le cu ''pkill'' de data asta.
</hidden>

<code bash>
student@midgard:~$ kill -15 2628
</code>

Repornim procesul ''find''. De data asta folosim o comandă care nu implică determinarea PID-ului:

<code bash>
student@midgard:~$ pkill find
</code>

Instalați pe sistemele voastre ''chromium-browser'', dacă acesta nu e deja instalat. Deschideți browserul și 10 tab-uri în care să intrați pe diverse site-uri. Deteminați PID-urile tutror proceselor pornite de chromium-browser

Dorim să omorâm toate aceste procese. Pentru aceasta putem folosi în loc de ''kill PID1 PID2 ... PID_N'' putem folosi mai eficient:

<code bash>
student@midgard:~$ killall chromium-browser
</code>

Ce s-a întâmplat cu site-urile care erau deschise?

<hidden>
Un utilizator poate trimite un semnal unui proces folosind comanda ''kill'' (știm, nefericit nume de comandă!). Spuneți-le că sunt unele procese //pasive// (nu e nevoie să precizați numele de ''daemon'') cu care nu poți comunica decât prin semnale. 

<code bash>
student@midgard:~$ kill -l   
</code>

să vadă și ei toate semnalele.

** Le explicați, pe scurt, pe cele importante de care au nevoie să știe.**

La grupe avansate puteți arăta cum pornind în fundal ne arată bash niște informații, precum killed/Terminated, în funcție de semnalul trimis: 

<columns 50% 50% ->

<code bash>
student@midgard:~$ sleep 1000
</code>

<newcolumn>

<code bash>
student@midgard:~$ sleep 1000
</code>

</columns>

<code bash>
student@midgard:~$ kill $PID1
[1]-  Terminated              sleep 1000
student@midgard:~$ kill -9 $PID2
[2]+  Killed                  sleep 1000
</code> 

<code bash>
student@midgard:~$ sleep 1000 &
[1] 14876
student@midgard:~$ sleep 1000 &
[2] 14877
student@midgard:~$ ps
  PID TTY          TIME CMD
13038 pts/0    00:00:00 bash
14876 pts/0    00:00:00 sleep
14877 pts/0    00:00:00 sleep
14878 pts/0    00:00:00 ps
student@midgard:~$ pkill sleep 
[1]-  Terminated              sleep 1000
[2]+  Terminated              sleep 1000
student@midgard:~$ ps
  PID TTY          TIME CMD
13038 pts/0    00:00:00 bash
14886 pts/0    00:00:00 ps
</code>

Ca fun fact, puteți face un benchmark minim  ''Firefox'' vs. ''Chromium'', deschideți 3-4 taburi în fiecare și arătați-le că firefox e tot un singur proces în schimb ce chromium sunt **over 9000!!!***.

<code bash>
student@midgard:~$ pgrep chromium
16614
16623
16627
16651
16662
student@midgard:~$ pgrep firefox
16539

</code>
</hidden>







====== Exerciții ======

===== [0] Pregătire setup laborator (0.5p) =====

Pentru a descărca fișierele necesare acestui laborator deschidem un terminal (folosim combinația de taste ''**Alt+Ctrl+t**'') și clonăm repository-ului oficial uso. 

<note important>Ne asigurăm că suntem în ''/home/student''</note>

Folosim comanda:

<code bash>
student@midgard:~$ git clone https://github.com/systems-cs-pub-ro/uso
</code>
 
În directorul ''/home/student/uso/lab04'' găsim fișierele necesare pentru laboratorul 4.

<note tip>Recomandăm rezolvarea exercițiilor pe mașina virtuală USO pe care o veți avea și la teme și la testul practic. Informații pas cu pas despre importul și pornirea acesteia se află în secțiunea [[:uso:resurse:mv|Mașina virtuală]].

Pentru acest laborator putem porni la lucru cu mașina cu interfață grafică, aceasta se află în ''/mnt/unfrozen''. Drept urmare importăm fișierul ''/mnt/unfrozen/uso_2016_2017_gnome.ova''

</note>
===== Utilizatori =====



==== [1] Adăugarea de noi utilizatori și de grupuri (1.5p) ==== 

Ca administratori ai infrastructurii IT a școlii de care răspundeți ați primit [[https://docs.google.com/spreadsheets/d/15LxIrhz0JTdLgWJqyHwj4hfVOg_uW6TyRnUbKqEtB8Y/edit#gid=0|următorul excel]] cu nume de utilizatori și grupuri din care trebuie să facă parte, conform cu politica școlii. 

Sarcina voastră este să adăugați în sistem grupurile și apoi utilizatorii, utilizatorii să îi înscrieți în grupuri conform cu excelul primit. 

De asemenea, trebuie să configurați următoarele parole:
  * Studenții vor avea parola ''student''
  * Profesorii vor avea parola ''profesor007''
  * Adminii vor avea parola ''admin1234''

Pentru cei care sunt în mai multe grupuri simultan alegeți parola mai dificilă (să conțină cifre diferite). 

<note>Pentru **verificarea** adăugării utilizatorilor în sistem trebuie să inspectăm fișierele: ''/etc/passwd'' și pentru grupuri ''/etc/group''. De asemenea, pentru a vedea grupurile din care face parte un anumit utilizator (să zicem ''dan'') și totodată existența sa în sistem mai putem folosi comanda:

<code bash>
student@uso~$ id dan
</code>

De asemenea, pentru a nu cauta in fisierele ''/etc/passwd'' sau ''/etc/group'' putem folosi comanda [[http://man7.org/linux/man-pages/man1/getent.1.html|getent]] ca mai jos pentru verificarea direct a setarilor pentru un user sau un grup:

<code bash>
student@uso~$ getent passwd dan
dan:x:1003:1003:Dan:/home/public/dan:/bin/bash
student@uso~$ getent group gdm
gdm:x:42:

</code>

</note>

<solution>
Pentru fiecare username din excel, pe sisteme Debian folosim comanda ''adduser'' care ne va prompta pentru mai multe configuratii printre care:
    * parola 
    * full name, work room etc. 

Pentru adaugarea grupurilor in sistem folosim comanda ''addgroup NUME_GRUP''. 

Atat ''adduser'' cat si ''addgroup'' trebuie prefixate cu ''sudo'' deoarece e nevoie de drepturi privilegiate/de administrare. 

Pentru a adauga un user in unul sau mai multe grupuri se foloseste comanda ''usermod'' ca in scenariul de mai jos

<code bash>
mihai@wormhole:~$ sudo adduser gigel
Adding user `gigel' ...
Adding new group `gigel' (1002) ...
Adding new user `gigel' (1002) with group `gigel' ...
Creating home directory `/home/gigel' ...
Copying files from `/etc/skel' ...
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
Changing the user information for gigel
Enter the new value, or press ENTER for the default
        Full Name []:
        Room Number []:
        Work Phone []:
        Home Phone []:
        Other []:
Is the information correct? [Y/n]
mihai@wormhole:~$ sudo addgroup studentii
Adding group `studentii' (GID 1003) ...
Done.
mihai@wormhole:~$ sudo usermod gigel -G studentii,sudo
mihai@wormhole:~$ id gigel
uid=1002(gigel) gid=1002(gigel) groups=1002(gigel),27(sudo),1003(studentii)
</code>

</solution>
==== [2] Schimbarea homedir-ului altui utilizator (1p) ====

Configurați sistemul astfel încât home directory-ul utilizatorului ''dan'' în loc de ''/home/dan'' să fie ''/home/public/dan''. Creați directorul dacă acesta nu există. 

Indicație: Folosim [[http://linux.die.net/man/8/usermod|usermod (modify a user account)]]. Căutați după ''new login directory''.   

**Pentru verificare** : Apăsați ''Ctrl+D'' pentru a reveni la terminalul în care erați autentificați ca ''student'' după care încercați comanda ''su - dan''. Dați ''pwd'' și verificați că homedir-ul acestuia e cel configurat cu ''usermod''. Alt mod de a verifica este inspectarea fișierului ''/etc/passwd'' și căutând linia care conține ''dan''. 

<note tip>Pentru a ne autentifica cu un anumit utilizator și a ne muta în homedir-ul lui folosim  ''su - dan'' in loc de simplu ''su dan''</note>

<solution>
<code bash>
sudo usermod dan -d /home/public/dan
</code>
</solution>
==== [3a] Drepturi de sudo pentru un utilizator (0.5p) ====

Suntem autentificați ca utilizatorul ''corina'' și vrem să instalăm un pachet. Observăm totuși că nu avem permisiuni.

<code bash>
corina@midgard:~$ sudo apt-get install tree
[sudo] password for corina: 
corina is not in the sudoers file.  This incident will be reported.
</code>

<note tip>
Pentru a acorda //drepturi de sudo// unui utilizator se folosește comanda ''visudo''. Reveniți la shellul utilizatorului ''student'' (''Ctrl+D'') și tastați comanda:

<code bash>
student@midgard:~$ sudo visudo
</code>
</note>

Dați drepturi utilizatorului ''corina'' de a instala pachete in sistem, fără a i se cere parola. Puteți vedea un exemplu de configurație pe [[http://askubuntu.com/questions/139723/sudo-does-not-ask-for-password|askubuntu]]. 

<note>**Verificare:** Reautentificați-vă drept ''corina'' și încercați din nou să rulați o comandă de instalare de pachete în sistem folosind ''sudo''.</note>

<solution -hidden>
<code bash>
student@midgard:~$ su - corina
Password: 
corina@midgard:~$ sudo apt-get intstall tree
[sudo] password for corina: 
corina is not in the sudoers file.  This incident will be reported.
corina@midgard:~$ logout
student@midgard:~$ sudo visudo 
[sudo] password for student: 

# adaugam linia corina ALL=(ALL:ALL) ALL în fișierul /etc/sudoers

student@midgard:~$ su - corina
Password: 
corina@midgard:~$ sudo apt-get intstall tree
[sudo] password for corina: 
E: Invalid operation intstall
corina@midgard:~$ sudo apt-get install tree
Reading package lists... Done
Building dependency tree  
</code>

</solution>

==== [3b] Drepturi de sudo pentru un grup (0.5p) ====

În același mod configurați sistemul astfel încât utilizatorii din grupul ''profesor'' să aibă drepturi depline de ''sudo'' în sistem. 

Autentificați-vă în sistem ca ''alex'' și ca ''mihai'' și **verificați** că funcționează comanda:

<code bash>
alex@uso:~$ sudo apt-get install rig
</code>

Asigurați-vă că nu apare eroarea (dacă apare înseamnă că ați greșit configurația din ''visudo''): 

<code bash>
(...)
alex is not in the sudoers file. This incident will be reported.
(...)
</code>

<solution -hidden>

Linia ce trebuie configurata cu ''sudo visudo'': 

<code bash>
# Members of the admin group may gain root privileges
%profesor ALL=(ALL) ALL
</code>

utilizatorul ''alex'' trebuie sa fie in grupul ''profesor'':

<code bash>
sudo usermod alex -G profesor
</code>

Verificam cu comanda ''id alex'' grupurile din care face parte ''alex''

</solution>
===== Procese =====


==== [4] Lucrul cu procese în backgroud/foreground (2p) ====
Mergeți în directorul ''/home/student/uso/lab04'' și rulați scriptul ''bg-proc.sh'':

<code bash>
student@midgard:~$ cd uso/lab04
student@midgard:~$ ./bg-proc.sh 
Tick!
Tock!
Tick!
...
</code>

Observăm că procesul rulează la infinit și afișează pe ecran un mesaj din secundă în secundă. Încercăm să rulăm o comandă simplă, spre exemplu ''ls'', dar vedem că ea este ignorată. Acest lucru se datorează faptului că procesul nostru se află în **foreground**, așa că tot ce tastăm noi se duce practic ca input pentru respectivul proces. Căutați în cheatsheet o combinație de taste ce trimite procesul nostru în **background**.

Verificăm că procesul există încă. Pentru aceasta tastați comanda ''ps''. Dorim acum să repornim procesul, dar nu mai vrem să fie tot în **foreground**, ci vrem să avem access și la shell în acest timp. Pentru aceasta folosim comanda ''bg''. Observați că imediat după ce o tastăm au reînceput să apară mesajele pe ecran. Tastați iarăși comanda ''ls'' și vedem că de data aceasta ea funcționează //aproape// așa cum ne așteptăm. Afișează fișierele și directoarele din directorul curent, dar în același timp sunt afișate și mesajele periodice ale procesului nostru.

<solution -hidden>
<code bash>
student@midgard:~$ ./bg-proc.sh 
Tick!
ls
Tock!
^Z
[1]+  Stopped                 ./bg-proc.sh
student@midgard:~$ ps
  PID TTY          TIME CMD
 8960 pts/0    00:00:00 bash
 9209 pts/0    00:00:00 bg-proc.sh
 9224 pts/0    00:00:00 ps
student@midgard:~$ bg
[1]+ ./bg-proc.sh &
student@midgard:~$ Tick!
ls
batman.sh      bg-proc.sh     it-s-a-trap.sh
student@midgard:~$ Tock!
student@midgard:~$ ^C
student@midgard:~$ Tick!
^C
student@midgard:~$ Tock!
</code>
</solution>

<note tip>
Fenomenul de mai sus se produce datorită faptului că terminalul nostru este legat la //ieșirea// (**stdout**) a două procese, ''ls'' și ''bg-proc.sh''. Mai multe detalii despre cele 3 intrări/ieșiri standard ale unui proces puteți găsi [[http://en.wikipedia.org/wiki/Standard_streams|aici]].
</note>

==== [5] Terminarea unui set de procese (1.5p) ====

Deschideți atât browser-ul Firefox, cât și browser-ul Chromium. Deschideți câte 5 tab-uri în fiecare browser. Folosind [[http://linux.die.net/man/1/ps|ps]], sau mai util [[http://linux.die.net/man/1/pgrep|pgrep]], identificați PID-urile proceselor deschise de cele două browsere. 

Folosind [[http://linux.die.net/man/1/htop|htop]] monitorizați consumul de resurse al acestor procese (e.g. CPU percent usage, RAM usage). 

Ce se va întâmpla la rularea următoarei comenzi? Vom pierde toată sesiunea din Firefox?

<code bash>
pkill -f firefox
</code>

Folosind PID-urile identificate anterior, trimiteți semnalul ''SIGINT (2)'' procesului ''chrome'' cu cel mai mare PID. Pierdem toată sesiunea în acest caz? Dar dacă rulăm comanda de mai jos, similar cu cea trimisă lui Firefox?

<code bash>
pkill chromium
</code>

Despre [[http://linux.die.net/man/1/pkill|pkill]] puteți citi și în [[http://www.thegeekstuff.com/2009/12/4-ways-to-kill-a-process-kill-killall-pkill-xkill/|acest articol]].

Despre monitorizarea proceselor și trimiterea semnalelor recomandăm [[http://www.cyberciti.biz/faq/kill-process-in-linux-or-terminate-a-process-in-unix-or-linux-systems/|acest articol]].  


==== [6] Terminarea forțată a unui proces (1p) ====
Mergeți în directorul ''/home/student/uso/lab04'' și rulați scriptul ''it-s-a-trap.sh''. Eram obișnuiți ca atunci când avem un proces în **foreground** să-l putem opri cu combinația de taste ''Ctrl+C'', însă observăm că acest lucru nu mai funcționează în cazul procesului nostru.

<code bash>
student@midgard:~/uso/lab04$ ./it-s-a-trap.sh 
Still running . . . 
Still running . . . 
^CIT's A TRAP!
Still running . . . 
^CIT's A TRAP!
...
</code>

Porniți un alt terminal și aflați PID-ul procesului folosind comanda ''ps''. După ce l-ați aflat, haideți să încercăm să-l omorâm așa cum am făcut cu celălalt proces la exercițiul precedent.

<code bash>
student@midgard:~$ ps U student
  PID TTY      STAT   TIME COMMAND
 1545 ?        Sl     0:00 /usr/bin/gnome-keyring-daemon --daemonize --login
 12361 pts/25   S+     0:00 /bin/bash ./it-s-a-trap.sh
12371 pts/25   S+     0:00 sleep 3
12372 pts/26   R+     0:00 ps U student
student@midgard:~$ kill 12361
</code>

încercați să-i trimiteți diferite semnale, de exemplu ''SIGTERM'', ''SIGINT'', ''SIGQUIT'' și observați ce se întâmplă. Cum reacționează procesul la ele?

Pentru a afișa lista de semnale disponibile folosim comanda:
<code bash>
student@midgard:~$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
</code>

<columns 50% 50% ->

<code bash>
student@midgard:~$ kill -SIGTERM 12361
student@midgard:~$ kill -SIGINT 12361
</code>

<newcolumn>
<code bash>
student@midgard:~/uso/lab04$ ./it-s-a-trap.sh 
Still running . . . 
IT's A TRAP!
Still running . . . 
IT's A TRAP!
Still running . . . 
Still running . . . 
...
</code>

</columns>

S-ar părea că procesul nostru este imun la semnale. Să încercăm și cu semnalul ''SIGKILL''. Trimiteți-i-l și pe acesta. Ce s-a întâmplat cu procesul nostru?

<note tip>
Singurul semnal care nu poate fi interceptat și ignorat de către niciun proces este semnalul ''SIGKILL'', așadar el garantându-ne terminarea procesului. Dezavantajul este însă că procesul va fi terminat brusc, fără a mai realiza nicio procedură de salvarea a stării curente, așa cum se întâmplă în cazul altor semnale precum ''SIGTERM''.
</note>

<note tip>
Putem trimite semnale unui proces și doar folosind indexul semnalui, nu neapărat numele lui. Astfel comanda ''kill -9 $PID'' este echivalentă cu comanda ''kill -SIGKILL $PID'', de exemplu. 
</note>

<note important>Rețineți că la folosirea ''kill -9'' resursele ocupate de un proces (e.g.: fisiere) e foarte posibil să nu fie eliberate deloc sau să nu fie eliberate corect. </note>


<solution -hidden>
<columns 50% 50% ->
<code bash>
student@midgard:~$ kill -SIGKILL 12361
</code>
<newcolumn>
<code bash>
student@midgard:~/uso/lab04$ ./it-s-a-trap.sh 
Still running . . . 
[1]    12361 killed     ./it-s-a-trap.sh
</code>
</columns>
</solution>

==== [7] Resurse ocupate de un proces (1.5p) ====

Porniți instalarea următorului pachet (are în jur de ''1.5 GB'') și lăsați instalarea să curgă în terminal: 

<code bash>
student@uso:~$ sudo apt-get -y install texlive-full
</code>

Deschideți un alt terminal. Încercați să instalați un singur pachet, spre exemplu:

<code bash>
student@uso:~$ sudo apt-get -y install toilet
</code>

Ce eroare obținem? Am folosit drepturile privilegiate, iar pachetul există: 

<code bash>
E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)
E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?
W: Could not lock the cache file; this usually means that dpkg or another apt tool is already installing packages.  Opening in read-only mode; any changes you make to the states of packages will NOT be preserved!
</code>

Între timp am uitat de instalarea lungă pornită în fundal în celălalt terminal. Identificați PID-ul procesului care ține resursa ''/var/lib/dpkg/lock'' ocupată. 

<note tip>În cazul de față, în Linux, o dată pornită o instalare se pune lock pe o resursă și alte procese care încearcă să pornească o instalare nu mai au voie până când resursa nu e eliberată. 

Pentru depanarea problemei noastre cel mai bun utilitar este folosirea [[http://linux.die.net/man/8/lsof|lsof]] (cu ajutorul lui putem identifica ce procese țin deschis un anumit fișier) sau o variantă simplificată, dedicată acestei sarcini: [[http://linux.die.net/man/1/fuser|fuser]]. 
Folosiți utilitarul ales (''lsof'' sau ''fuser'') împreună cu ''sudo''.
</note>

După ce ați identificat PID-ul procesului care ține ocupată resursa ''/var/lib/dpkg/lock'' listați și celelalte fișiere deschise de acel proces folosind [[http://linux.die.net/man/5/proc|procfs]].

==== [BONUS #1] Procese detașate de terminal [1 Karma WoUSO] ====

<note warning>Pentru acest exercițiu avem nevoie de pachetul ''transmission-cli''. Îl putem instala folosind comanda
<code bash>
student@midgard:~$ sudo apt-get install transmission-cli
</code>
</note>

Folosiți ''Transmission'' în linie de comandă pentru a descărca o imagine de Ubuntu, [[http://releases.ubuntu.com/17.04/ubuntu-17.04-desktop-amd64.iso.torrent?_ga=2.179407716.1129929276.1508229525-1809341997.1504894444|de aici]]. Descărcați fișierul ''.torrent'' în ''/home/student/Downloads''.

<code bash>
student@midgard:~$ transmission-cli ~/Downloads/ubuntu-17.04-desktop-amd64.iso.torrent
</code>

Dintr-un alt terminal determinați PID-ul acestui proces. 
Închideți terminalul din interfața grafică (''X'' din colțul din dreapta sus). Căutați din nou procesul după identificator. Ce s-a întâmplat cu procesul nostru ''transmission-cli'' tocmai creat? Care credeți că este cauza?

<solution>
Variante de cautare a procesului in sistem:
<code bash>
ps aux|grep transmission
pgrep transmission-cli
</code>
</solution>

Deschideți din nou un terminal, dar de data folosiți-vă de comanda ''nohup'' (''man nohup'') pentru a lansa procesul ''transmission-cli'' pentru descărcarea imaginii de Ubuntu. Închideți din nou terminalul din interfața grafică. Observați că procesul rămâne în viață. Determinați PID-ul acestui proces. 

Ce fel de semnal se generează atunci când închidem terminalul și pe care a doua oară procesul ''transmission-gtk'' îl ignoră?

<solution>
Este vorba de semnalul ''SIGHUP''
</solution>

<hidden>
Folosiți comanda lsof pentru a vedea ce fișiere a deschis procesul nostru. Comanda va avea următoarea structură:

<code bash>
student@midgard:~$ lsof -p $PID_proces
</code>
</hidden>

==== [BONUS #2]  Trimiterea de semnale unui proces [1 karma WoUSO] ====

Mergeți în directorul ''/home/student/uso/lab04'' unde găsiți scriptul ''batman.sh''. Rulați-l. Procesul interceptează toate semnalele cu indecși de la 1 la 13, mai puțin 9 (din motive evidente). De fiecare dată când primește un semnal cu indexul între 1 și 13 el afișează pe ecran un caracter. Mai jos aveți maparea dintre indecșii semnalelor și caracterul afișat:

<columns 50% 50% ->

^Index semnal ^ Caracter ^
| 1           |  o       |
| 2           |  u       |
| 3           |  c       |
| 4           |  d       |
| 5           |  e       |
| 6           |  z       |

<newcolumn>

^Index semnal ^ Caracter ^
| 7           |  s       |
| 8           |  h       |
| 10          |  (space) |
| 11          |  r       |
| 12          |  k       |
| 13          |  l       |

</columns>
 Într-un alt terminal aflați pid-ul procesului și trimiteți-i semnale astfel încât procesul să afișeze pe ecran șirul de caractere ''uso rullz''. 

<solution -hidden>
<columns 50% 50% ->
<code bash>
student@midgard:~$ ./batman.sh
uso rullz[1]    25662 killed     ./batman.sh
</code>

<newcolumn>

<code bash>
student@midgard~:$ ps U student
18149 s000  S      0:01.57 bash
25662 s000  S+     0:00.02 /bin/bash ./batman.sh
25731 s000  S+     0:00.00 sleep 1
24968 s001  Ss     0:00.61 login -pf student
24969 s001  S      0:00.19 bash
25732 s001  R+     0:00.00 ps U student
student@midgard~:$ kill -2 25662
student@midgard~:$ kill -7 25662
student@midgard~:$ kill -1 25662
student@midgard~:$ kill -10 25662
student@midgard~:$ kill -11 25662
student@midgard~:$ kill -2 25662
student@midgard~:$ kill -13 25662
student@midgard~:$ kill -13 25662
student@midgard~:$ kill -6 25662
student@midgard~:$ kill -9 25662
</code>
</columns>

</solution>

<hidden>

==== [BONUS #3] Recuperarea unui fișier folosind procfs [1 Karma WoUSO] ====

Descărcați următorul film: [[https://drive.google.com/file/d/0BypiZKffc_dBelBlNmRpN2IwZ00/view?usp=sharing|link ]]. Deschideți filmul din linie de comandă folosind ''mplayer'':

<code bash>
student@uso:~$ mplayer /path/to/movie/file
</code>

În timp ce ''mplayer'' rulează, ștergeți filmul. Deși ''mplayer'' redă filmul, fișierul pare definitiv pierdut. Nu e chiar așa. Folosind ''lsof'' inspectați fișierele deschise de acesta. Printre ele se află și filmul nostru. Determinați și PID-ul procesului ''mplayer''. 

Copiați din ''procfs''-ul aferent lui ''mplayer'' din directorul ''fd'' (''/proc/$(pidof mplayer)/fd'') fișierul care era inițial filmul nostru într-un alt director. Deschideți fișierul copiat. Am recuperat filmul pierdut!

Pașii descriși în exercițiu, împreună cu explicațiile aferente se pot găsi [[http://www.hackinglinuxexposed.com/articles/20020507.html|în acest articol]].

<solution -hidden>
Să vă asigurați că studenții nu descarcă acel film din browser (File->Save As) și apoi vă arată direct rezultatul. :)
</solution>

</hidden>
===== Sumar. Cuvinte cheie =====
  * Utilizator (user): cont cu care ne putem autentifica pe un sistem. Sunt identificați printr-un UID **U**ser **ID**
  * UID-ul lui ''root'' este 0. PID-ul lui ''init'' este 1.
  * Adăugare utilizatori: ''adduser'', ''deluser''. Mai generale: ''useradd'', ''userdel''.
  * Modificarea proprietăților unui utilizator: ''usermod''
  * Schimbă parola: ''passwd''
  * Execută o comandă cu drepturi elevate: ''sudo''
  * Proces: executabil care rulează în momentul de față. Mai multe rulări, mai multe procese (fiecare cu al său).
  * PID: **P**rocess **ID**
  * PPID: **P**arent **P**rocess **ID**
  * Vizualizarea proceselor ce rulează la un moment dat: ''ps'', ''pstree''
  * Vizualizarea proceselor ce rulează la un moment dat într-un mod interactiv: ''top'', ''htop''
  * Trimiterea de semnale unui process: ''kill''. ''kill -9 $PID'' pentru a fi siguri că procesul moare.
  * Rularea de procese în background: ''&''. Spre exemplu <code bash>student@midgard:~$ firefox & </code>
  * Terminarea tuturor proceselor pornite din același executabil: ''killall'', ''pkill''
  
  