~~SHOWSOLUTION~~
====== Laborator 02 - Utilizarea sistemului de fișiere. Comenzi de bază. ======

<hidden>
Încercați să vă încadrați în **30 min** de demo, astfel încât la cel târziu și 35 ei să se apuce de exerciții.
</hidden>
<hidden>
Spuneți-le despre World of USO. De asemenea, asigurați-i că cineva îi va adăuga în grupa corespunzătoare cât de repede se poate, dacă se plânge cineva că nu poate juca challengeuri.
</hidden>

<hidden>
===== World of USO =====
A început [[https://wouso.cs.pub.ro/2015/|World of USO]]. Este un joc de tip trivia, realizat de studenți ai facultății de Automatică și Calculatoare special pentru studenții de la USO. Jocul are mai multe activități posibile, cum ar fi: Question of the Day, Challenge (în care vă provocați la un set de 5 întrebări între voi), Weekly Quest, Special Quest și, desigur, pentru cei puternici, Final Quest.
</hidden>
<hidden>
<note important>
**Am lansat jocul World of USO (WoUSO) !!! **. Accesati https://wouso.cs.pub.ro/

World of USO este un joc simplu de tip trivia realizat special pentru studenții cursului de USO, care are 3 componente majore: Question of the Day, Challenge (în care vă provocați la un set de 5 întrebări între voi) și The Quest. Autentificarea în joc se face folosind aceleași credențiale cu care vă autentificați pe platforma Moodle (cs.curs.pub.ro).

</note>
</hidden>
===== Utilizare terminal =====

În Ubuntu GNOME 18.04 pentru a deschide un terminal nou:

^ Scurtătură             ^ Descriere                                          ^
| **''Ctrl+ALT+t''**   | pentru a o nouă fereastră de terminal              |


Puteți folosi următoarele scurtături în terminal:

^ Scurtătură             ^ Descriere                                          ^
| **''Ctrl+Shift+t''**   | pentru a deschide un nou tab                       |
| **''Ctrl+PageDown''**  | pentru a merge la tab-ul urmator                   |
| **''Ctrl+PageUp''**    | pentru a merge la tab-ul precedent                 |
| **''Alt+<index>''**    | pentru a sări direct la un tab                     |
| **''Ctrl+d''**         | pentru a închide un tab (sau comanda **''exit''**) |

Pentru a naviga (scrolling) în cadrul unui terminal, mai ales atunci când o comandă afișează mult text, folosiți următoarele scurtături:

^ Scurtătură           ^ Descriere               ^
| **''Shift+PgDown''** | pentru a derula în jos  |
| **''Shift+PgUp''**   | pentru a derula în sus  |

Alte scurtături utile: 

^ Scurtătură           ^ Descriere               ^
| **''Ctrl+Shift+c''** | copiere text din terminal  |
| **''Ctrl+Shift+v''** | lipire text în terminal |
| **''Shift+Insert''** | lipire text în terminal |

===== Navigarea în paginile de manual =====

Cea mai importantă formă de documentație în Linux, atunci când nu avem acces la Internet, o reprezintă paginile de manual, accesibile cu ajutorul comenzii ''**man**''. 

De exemplu, pentru a afișa informații despre comanda ''echo'' (comandă ce afișează un mesaj la ieșirea standard), vom folosi comanda:

<code bash>student@uso:~$ man echo </code>

Paginile de manual sunt adesea de mari dimensiuni și avem nevoie să le parcurgem rapid (să navigăm prin ele). Pentru aceasta, după ce deschidem pagina de manual a unei comenzi, putem folosi combinațiile de taste de mai jos pentru a nagiva în pagină:

^ Tastă                                  ^ Scurtă descriere                                          ^
| /string_to_search                      | ''/'' (adică tasta //slash//) e folosită pentru a căuta **''string_to_search''** în pagina de manual |
| **''n''** (next)                       | pentru a merge la următoarea apariție a cuvântului căutat cu / |
| **''N''** (Shift + n)                  | pentru a merge la precedenta apariție a cuvântului             |
| **''q''** (quit)                       | pentru a închide pagina de manual                              |
| **''Enter''**                          | pentru a derula în jos o linie                            |
| **''f''** (forward) sau **''Space''**  | pentru a derula în jos un ecran                           |
| **''b''** (backward)                   | pentru a derula în sus un ecran                           |
| **''d''** (down)                       | pentru a derula în jos jumătate de ecran                  |
| **''u''** (up)                         | pentru a derula în sus jumătate de ecran                  |

===== Suport laborator =====

Pentru a obține informații detaliate despre noțiunile și tehnicile din acest laborator, recomandăm să consultați următoarele secțiuni din cartea de suport a cursului USO:

  * [[http://books.google.ro/books?id=_JFGzyRxQGcC&lpg=PA532&pg=PA58&redir_esc=y#v=onepage&q&f=false|3.2. Gestiunea pachetelor]]
  * [[http://books.google.com/books?id=_JFGzyRxQGcC&lpg=PA532&pg=PA74#v=onepage&q&f=false|4.2. Tipuri de fișiere]]
  * [[http://books.google.com/books?id=_JFGzyRxQGcC&lpg=PA532&pg=PA76#v=onepage&q&f=false|4.3. Operații uzuale asupra fișierelor și directoarelor]]

===== Obiective laborator =====

  * Familiarizarea cu linia de comandă în Linux
  * Familiarizarea cu comenzi simple în ''Bash'' (terminalul din Linux)
  * Utilizarea comenzilor pentru operațiuni similare realizate până acum din interfața grafică
  * Înțelegerea diferenței dintre căi relative și căi absolute 
 
===== Pe scurt despre Git =====

Pe parcursul laboratoarelor, pentru descărcarea fișierelor necesare laboratorului, vom folosi Git. 

Git este un sistem de source control management și e folosit pentru versionarea codului în proiectele software mari. 

Celor interesați să aprofundeze conceptele din spatele comenzii ''git'', precum și utilizări avansate, le recomandăm cursul practic online de pe [[http://gitimmersion.com/|gitimmersion]]. 

===== Demo =====

Pentru început, vrem să ne acomodăm cu cele mai importante comenzi din linia de comandă, în special cele care lucrează cu fișiere și directoare. Îndrumați de asistent, vom descoperi împreună cum putem folosi linia de comandă pentru a lucra cu sistemul de fișiere și pentru a face acțiuni mai rapid ca în interfața grafică.

<note tip>
Avem și un [[uso:resurse:cheatsheet|cheatsheet]] pe care îl putem folosi ca să ne reamintim cele mai frecvente comenzi.
</note>

Să începem!

<hidden>

<note important>
Înainte de toate, spuneți-le de [[uso:resurse:cheatsheet|cheatsheet]]!!!!!!
</note>

Începeți cu (pentru că sigur au văzut deja la curs cum arată niște comenzi, să ne lămurim de la început) faptul că exită 3 formate pentru opțiunile unei comenzi:
  * formatul lung (de exemplu ''%%--help%%'')
  * formatul GNU (ca în ''ls -l'')
  * formatul BSD (''ps aux'')

<note tip>
Este de preferat să întrebați de fiecare dată ce cred ei că va face o comandă înainte de a da ENTER. Vă rog să îi implicați cât mai mult în demo, că altfel vor dormi așa cum o fac la curs.
</note>

</hidden>

==== 1. Navigare în sistemul de fișiere ====

Deschideți un terminal. Clonați conținutul [[https://github.com/systems-cs-pub-ro/uso|repository-ului oficial uso]] folosind comanda de mai jos: <code bash>
student@uso:~$ git clone https://github.com/systems-cs-pub-ro/uso 
</code> 

Ne propunem să lucrăm cu acele comenzi care ne ajută să parcurgem directoarele din sistemul de fișiere (adică să-l traversăm). Apoi să folosim comenzile pentru listarea conținutului unui director și pentru afișarea conținutului unui fișier.

Foarte importantă este distincția între o cale absolută (o cale către un director care pornește din directorul rădăcină, exemplu: ''/home/student'') și o cale relativă la directorul curent (folosind intrările speciale ''.'' - directorul curent și ''..'' - directorul părinte).

Urmăriți cu atenție secvența de comenzi de mai jos. Dacă vreți să dați și voi comenzile pe stația la care lucrați, __folosiți cât mai des tasta ''**TAB**''__ atunci când dați un parametru comenzii ''ls'' sau ''cd''. 

<code bash>
[student@uso demo]$ pwd
/home/student/uso/lab02/demo

[student@uso demo]$ tree .
.
|-- ac_dc
|   |-- angus
|   |-- bon
|   |-- brian
|   |-- chris
|   |-- cliff
|   |-- dave
|   |-- george
|   |-- malcom
|   |-- mark
|   `-- phil
|-- cargo
|-- hammerfall
|   |-- anders
|   |-- jesper
|   |-- joacim
|   |-- magnus
|   |-- oscar
|   |-- pontus
|   `-- stefan
|-- iris
|-- metallica
|-- nightwish
|-- nirvana
|-- phoenix
`-- slayer

</code>

Acum că am văzut structura directoarelor, haideți să navigăm prin ele:

<code bash>
[student@uso demo]$ cd ac_dc  # aici am folosit o cale relativă la directorul curent
[student@uso ac_dc]$ ls
angus  bon  brian  chris  cliff  dave  george  malcom  mark  phil
[student@uso ac_dc]$ cd .. # Am navigat în directorul părinte directorului ac_dc, care este /home/student/uso/lab02/demo
[student@uso demo]$ ls -R    
.:
ac_dc  cargo  hammerfall  iris  metallica  nightwish  nirvana  phoenix  slayer

./ac_dc:
angus  bon  brian  chris  cliff  dave  george  malcom  mark  phil

./hammerfall:
anders  jesper  joacim  magnus  oscar  pontus  stefan

./metallica:

./nirvana:
[student@uso demo]$ cd /home/student/uso/lab02/demo/hammerfall # am fi putut folosi și cd hammerfall, dar am folosit cale absolută
[student@uso hammerfall]$ ls
anders  jesper  joacim  magnus  oscar  pontus  stefan
</code>

Lui ls îi putem da argument atât o cale relativă către un director sau un fișier, cât și o cale absolută:

<code bash>
[student@uso hammerfall]$ ls ../ac_dc   
angus  bon  brian  chris  cliff  dave  george  malcom  mark  phil

[student@uso hammerfall]$ ls -l ../ac_dc/brian
-rw-r--r-- 1 student all 0 Oct 17 08:56 ../ac_dc/brian

[student@uso hammerfall]$ ls -l ./anders
-rw-r--r-- 1 student all 0 Oct 17 08:56 ./anders

[student@uso hammerfall]$ ls -l anders
-rw-r--r-- 1 student all 0 Oct 17 08:56 anders

[student@uso hammerfall]$ ls -l /home/student/uso/lab02/demo/hammerfall/oscar  
-rw-r--r-- 1 b46099 all 0 Oct 17 08:56 /home/student/uso/lab02/demo/hammerfall/oscar
</code>

<note important> Mare atenție la căile relative vs. cele absolute. O cale relativă este o cale raportată la directorul curent, în timp ce o cale absolută este raportată la directorul rădăcină (''/''). O cale relativă începe, de obicei, cu un nume, cu ''.'' sau cu ''..'', în timp ce o cale absolută începe întotdeauna cu ''/''. De reținut faptul că și ''~/uso'' este tot o cale absolută, chiar dacă începe cu caracterul ''~'', acest lucru fiind datorat faptului că ''~'' este doar un alias către directorul ''home'' al utilizatorului curent (''/home/student'').</note>

Cum am văzut și mai sus, exemple de folosire a căilor relative sunt:
<note tip>Țineți cont de folosirea tastei **''TAB''**.</note>

<code bash>
[student@uso demo]$ ls hammerfall        # ls h<TAB>
[student@uso demo]$ ls -l .
[student@uso demo]$ cd ./ac_dc           # cd ./a<TAB>
[student@uso ac_dc]$ ls ../hammerfall    # ls ../h<TAB>
[student@uso ac_dc]$ ls ../../demo/iris  # ls ../../d<TAB>/i<TAB>
</code>

Câteva exemple de utilizare a căilor absolute:
<code bash>
[student@uso demo]$ ls /
[student@uso demo]$ tree /home/student/uso/lab02/demo/hammerfall   # ls /h<TAB>/stu<TAB>/uso/demo/h<TAB>
[student@uso demo]$ ls -l ~/uso/lab02/demo/hammerfall              # ls ~/uso/lab02/d<TAB>/h<TAB>
[student@uso demo]$ tree -L 1 ~
</code>

Acum să vedem câteva erori care pot să apară. Ce credeți că se întâmplă mai jos? Care este cauza erorii apărute, ce greșeală a fost făcută? 

<code bash>
[student@uso hammerfall]$ ls -l brian
ls: cannot access brian: No such file or directory

[student@uso hammerfall]$ cd ..
[student@uso demo]$ cd nightwish
-bash: cd: nightwish: Not a directory

[student@uso demo]$ cd /home/student/uso/lab02/demo/scorpions
-bash: cd: /home/student/uso/lab02/demo/scorpions: No such file or directory

[student@uso demo]$ cd ac_dc
[student@uso ac_dc]$ cd ..
[student@uso demo]$ cd /nirvana
-bash: cd: /nirvana: No such file or directory
</code>

<note important>
Citiți cu atenție mesajele erorilor din Bash ori de câte ori o comandă nu funcționează. Oferă suficiente indicii despre rădăcina erorii. 
</note>

<note important>În general, orice comandă ''cd'' ar trebui urmată de una ''ls'' sau ''pwd'' în scop de verificare. Cum am văzut mai sus, uneori pot apărea erori, fie directorul nu există, fie nu avem permisiuni să îl accesăm, iar comanda se poate executa fără succes, prin urmare este **foarte important** ca orice comandă de modificare/alterare a stării curente să fie urmată de una de verificare. Câteva exemple de comenzi care fac pereche bună sunt: ''cd'' -- ''pwd''; ''touch'', ''mv'', ''rm'' -- ''ls''; ''echo'' -- ''cat'' etc.
</note>

<hidden>

Intrați în directorul ''~/uso/lab02/demo''

  * La eroarea cu ''cd nightwish'' nu a mers pentru că nu e director. Puteți da ''ls -l'' să le arătați că în stânga nu are un ''d'' de la director.
  * Arătați sau precizați efectul comenzilor ''cd'', ''cd ~'', ''cd -''. 
  * Arătați sau precizați efectul comenzii ''cd<SPACE><TAB>'' --> cum am dat ''ls'' fără a folosi ''ls''
  * Arătați sau precizați efectul comenzii ''cd me<TAB>''. 

<note important>**Insistați pe folosirea <TAB> nu treceți peste asta**</note>  

</hidden> 

<note important>
Folosiți tasta ''TAB'' ori de câte ori puteți. De multe ori e suficient să tastăm doar primele 2-3 litere din numele directorului sau fișierului pe care vrem să-l accesăm. Dacă există două sau mai multe directoare/fișiere care au același prefix, putem fie adăuga mai multe litere pentru a elimina ambiguitatea, fie tasta de două ori ''TAB'' pentru a afișa lista de hituri cu același prefix. Putem itera apoi prin lista de potriviri folosind tot tasta ''TAB''. 
</note>

Urmăriți exemplele de mai jos.

<code bash>
[student@uso demo]$ ls h<TAB>
anders jesper joacim magnus oscar  pontus stefan

[student@uso demo]$ cd ac_<TAB>

[student@uso ac_dc]$ ls c<TAB><TAB>
chris  cliff

[student@uso ac_dc]$ ls ch<TAB>
chris
</code>


==== 2. Utilitarul tree ====
Unul dintre utilitarele de bază este ''tree'', care poate lista conținutul directoarelor într-un format arborescent, fiind mai ușor de urmărit și înțeles organizarea sistemului de fișiere. De cele mai multe ori este suficientă o simplă comandă ''ls'', dar dacă vrem să vizualizăm și nivelurile inferioare din ierarhia de fișiere și directoare, ''tree'' poate fi foarte util.

Utilizat fără argumente, ''tree'' va lista toate fișiere și directoarele aflate //sub// directorul curent (''.'').

<code bash>
[student@uso demo]$ tree
.
├── ac_dc
│   ├── angus
│   ├── bon
│   ├── brian
│   ├── chris
│   ├── cliff
│   ├── dave
│   ├── george
│   ├── malcom
│   ├── mark
│   └── phil
├── cargo
├── hammerfall
│   ├── anders
│   ├── jesper
│   ├── joacim
│   ├── magnus
│   ├── oscar
│   ├── pontus
│   └── stefan
├── iris
├── nightwish
├── phoenix
└── slayer

2 directories, 22 files
</code>

''tree'' poate primi ca argument unul sau mai multe directoare și le va lista, independent, pe fiecare.

<code bash>
[student@uso demo]$ tree hammerfall ac_dc
hammerfall
├── anders
├── jesper
├── joacim
├── magnus
├── oscar
├── pontus
└── stefan
ac_dc
├── angus
├── bon
├── brian
├── chris
├── cliff
├── dave
├── george
├── malcom
├── mark
└── phil

0 directories, 17 files
</code>

În cazul în care dorim să afișăm un director care conține foarte multe fișiere și subdirectoare, putem limita nivelul până la care se face listarea folosind argumentul ''-L''.
<code bash>
[student@uso demo]$ tree -L 1
.
├── ac_dc
├── cargo
├── hammerfall
├── iris
├── nightwish
├── phoenix
└── slayer

2 directories, 5 files
</code>

<note>De notat faptul că tree poate să nu primească niciun argument sau, dacă primește, acesta trebuie să fie neapărat director, în caz contrar se va afișa o eroare.
<code bash>
[student@uso demo]$ tree iris
iris [error opening dir]
</code>
</note>
==== 3. Pagini de manual ====

În Linux, probabil cea mai folosită formă de documentație o reprezintă paginile de manual. Haideți să vedem care sunt comenzile pe care le folosim pentru a ne documenta în Linux și cum găsim informația utilă.

Căutarea unei comenzi: 

<code bash>
student@mint ~ $ apropos "remove files"
student@mint ~ $ apropos "copy files"
</code>

Localizarea unei comenzi:

<code bash>
student@mint ~ $ which dpkg
</code>

Localizare binar, sursă, dar și fișierele de care se folosește pagina de manual:

<code bash>
student@mint ~ $ whereis ls
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz
</code>

<hidden>

continuare output which dpkg
<code bash>
/usr/bin/dpkg
student@mint ~ $ whereis dpkg
dpkg: /usr/bin/dpkg /etc/dpkg /usr/lib/dpkg /usr/bin/X11/dpkg /usr/share/dpkg /usr/share/man/man1/dpkg.1.gz
student@mint ~ $ which iptables
/sbin/iptables
student@mint ~ $ whereis iptables
iptables: /sbin/iptables /usr/share/iptables /usr/share/man/man8/iptables.8.gz
</code>
  * Evident, vor întreba ce e ''dpkg''. Le explicați despre package management, pe scurt. Apoi le arătați cum își pot instala pachete, cum pot folosi ''apt-cache search'' pentru căutarea unor pachete și cum se face ''update'' la repositories + ''upgrade''. 
  * Întrebați dacă au idee de ce una e în **''/bin''** și alta în **''/sbin''**. 
  * Ce știu ei că se află în **''/bin''** de obicei? 
  * De la ce ar putea veni **''s''** în **''/sbin''**?
  * Dacă întreabă ce este **''iptables''**, reamintiți-le să folosească **''man''** cu încredere (același lucru pentru detalii cu privire la **''which''** sau **''whereis''**)

</hidden>
 
==== 4. Operații pe fișiere și directoare ====

Acum că știm să navigăm sistemul de fișiere, dorim să și creăm fișiere și directoare. Haideți să vedem cu ce comenzi putem crea, copia, muta și șterge fișiere și directoare.

<hidden>

A se folosi **''cp, mv, mkdir, touch, echo''**.
Puteți folosi folderul **''/tmp''** ca playground (cu ocazia asta le spuneți ce este).
Nu uitați să le reamintiți că folosiți TAB pentru a fi rapizi! Câteva sugestii de comenzi
în cazul lipsei de imaginație:


  * Să facem un micro-backup

<code bash> 
touch file_list.bak
cat file_list.bak      # to show that it is empty            
cp file_list file_list.bak
ls
cat file_list.bak
</code>

  *  Era nevoie de crearea fișierului cu **''touch''**? (dacă vor spune **DA** mai faceți o copiere, dar fără **''touch''**)

<code bash>
cp file_list file_list.bak2
</code>

  * Diferența dintre copy și move. Înainte de a da orice **''ls''**, întrebați cum cred că va arata outputul (tastați în terminal **''ls -l''** și nu dați enter) 

<code bash>
mkdir generated_files   
cp file_list generated_files/
mv file_list.bak generated_files/
ls -l generated_files/      
ls -l  
</code>

  * Ștergerea unor fișiere (întrebați care e diferența dintre delete-ul clasic dat în Windows în mod constant de ei și acest **''rm''**). 
 
<code bash>           
rm file_list      
ls
</code>

  * Concluzia la care trebuie să ajungă: mare grijă cu **''rm''**, pentru că nu există UNDO/Restore. Puteți intra într-o mică discuție despre permisiuni, de ce nu ai implicit drept de root (asta fiind una din multiplele cauze - poți șterge fișiere critice din sistem). Mai multe detalii vor avea în laboratorul 3. Pentru moment îi interesează **''sudo''** întrucât vor avea de instalat niște pachete și pentru asta trebuie să ai dreptul să o faci. 

</hidden>

==== 5. Wildcards ====

Poate vi se pare că durează mult să scrieți comenzi și că ați fi folosit mai ușor interfața grafică. Ei bine, linia de comandă are caractere speciale (de tipul //wildcards//) cu care putem face dintr-o singură comandă o acțiune pe mai multe fișiere. Să vedem cum putem face aceste lucru.

Să se listeze conținutul tuturor fișierelor cu extensia ''*.conf'' din ''/etc'': 

<code bash> ls /etc/*.conf </code>

Determinarea distributiei de Linux (de obicei nu stim exact cum se numește fișiereul, dar știm sigur că acesta conține cuvântul cheie ''release'')

<code bash>
cat /etc/*release*
</code>


<hidden>

  * Precizați cine face expansiunea (shell-ul, nu comanda). 
  * Comanda se execută ca și cum toate argumentele ar fi fost date de mână unul după altul
  * Funcționează deoarece majoritatea comenzilor din linux acceptă un număr variabil de argumente (vezi demo-ul cu ''cat'' de mai jos)
  * Luați acest cod C simplu, compilați-l și apoi rulați-l folosind globbing. Nu va funcționa pentru că am limitat explicit numărul de argumente posibile la unul singur:

<code C>
#include <stdio.h>

int main(int argc, char **argv)
{
        if(argc > 2) {
                printf ("Only one argument accepted \n");
                return -1;
        }

        printf("%s \n", argv[1]);

        return 0;
}

</code>

<code bash>
touch a.bak b.bak c.bak
rm *.bak
ls /etc/a*.conf
ls /etc/*.conf
ls /etc/init.d/*mount*
ls /etc/init.d/cr??    #exact two characters
ls /etc/[dabc]*.conf
</code>

Un demo interesant pentru ei va fi determinarea distributiei de Linux (de obicei nu stim exact cum se numeste fisierul, dar stim sigur ca se termina cu ''release''): 

<code bash>
cat /etc/*-release
</code>

Pe o distributie RedHat Enterprise 5 am vazut ca nu exista decat /etc/redhat-release. Pe Linux Mint erau cel putin 3 fisiere al caror output se concateneaza. 

  * Cu siguranță vor întreba ce sunt acele fișiere din **''/etc''**. Nu intrați în prea multe detalii, vor descoperi pe parcursul semestrului. 
  * Întrebați ce cred ei că se află în **''/etc/init.d''** (numele e destul de sugestiv să aibă măcar un student o idee). 
  * Reamintiți-le de problema **''rm''**. Dacă nu au grijă cum folosesc wildcard-urile pot strica totul. Sugerați-le ca atunci când nu sunt siguri în loc de **''rm''** să folosească **''ls''** când vor să șteargă fișiere (mai ales când execută cu drept de **''root''**) folosind expresii regulate și să se asigure că **''ls''** le dă exact lista fișierelor care se doreau a fi șterse. Să nu intre în capcane precum [[http://swarm.cs.pub.ro/~anpetre/pics/stupid_irc.png|aceasta]]

</hidden>

==== 6. Bonus/Extra: redirect stuff ====

Dacă ne mai rămâne timp în partea de demo, hai să discutăm despre o caracteristică foarte interesantă și utilizată din linia de comandă: redirectarea în fișiere. Adică posibilitatea ca output-ul unei comenzi să fie scris într-un fișier de unde să fie inspectat mai târziu.

<code bash>
student@uso:~$ ls > shaorma_files
student@uso:~$ cat shaorma_files
</code>

Dacă vom folosi aceasta redirectare din nou, ce se va întâmpla cu fișierul shaorma_files ?

<code bash>
student@uso:~$ echo "hello" > shaorma_files 
</code>

Dacă nu vrem să pierdem un conținut anterior, folosim //append mode//:

<code bash>
student@uso:~$ cat /etc/passwd >> shaorma_files
student@uso:~$ echo "uso rules" >> shaorma_files 
student@uso:~$ cat shaorma_files
</code>

<hidden>

  * STDIN redirect pentru cei avansați 

<code bash>
ls > file_list
sort < file_list
</code>

</hidden>
==== 7. Scurtă recapitulare ====

Haideți să recapitulăm lucrurile pe care le-am făcut în această sesiune de demo:
  * Am folosit comenzi simple de navigare prin sistemul de fișiere: ''cd'', ''pwd'', ''ls'', ''tree''.
  * Am văzut cum folosirea tastei ''TAB'' poate reduce considerabil timpul de tastare a comenzilor.
  * Am văzut cum putem consulta documentația pe Linux și cum putem căuta informația în paginile de manual.
  * Am creat fișiere și directoare folosind comenzi precum ''mkdir'', ''touch'', ''cp'', ''mv''. Pentru a le șterge, am folosi ''rm'' și ''rmdir''.
  * Am învățat că orice comandă de alterare trebuie urmată de una de verificare (''rm'' && ''ls'').
  * Am folosit wildcard-uri de forma ''*'' pentru a executa acțiuni simultan pe mai multe fișiere, lucru mai dificil de realizat în interfața grafică.
  * Am văzut cum putem folosi redirectarea în fișiere folosind operatorii ''>'', ''%%>>%%'' și ''<''.

<hidden>

<note tip>
Folosiți history pentru a le arăta comenzile rulate, dar și săgeată sus și recapitulați punctele importante. Celor mai avansati le puteti arata ''CTRL+r'' (reverse i search).
</note>

</hidden>
===== Exerciții =====

<note warning>Când lucrați la exerciții, atât la laborator, cât și la testul practic, fiți atenți în ce director vă aflați atunci când citiți cerința, dar și când le rezolvați. Cel mai sigur este să folosiți comanda <code bash> student@uso:~$ pwd </code> Semnificația este ''print working directory'' </note>

==== 0.0. Verificarea conturilor (0.5p) ====

<note important>
Raportați probleme cu conturi pe platforma [[https://support.curs.pub.ro/|https://support.curs.pub.ro/]]
</note>

Pe parcursul USO și al facultății avem nevoie să fim siguri că vă funcționează conturile în mai multe locuri. Avem următorul checklist

  - Intrați pe platforma [[http://studenti.pub.ro|http://studenti.pub.ro]]. Parola initiala pentru anul 1 este student + ultimele 6 cifre din CNP sau pasaport. Schimbati parola dupa prima autentificare. 
  - Pentru a afla user-ul de acces la [[http://cs.curs.pub.ro|http://cs.curs.pub.ro]] accesati pagina "Acces site cursuri" de pe http://studenti.pub.ro de la punctul 1
  - Au fost create e-mail-urile oficiale pentru studenti din partea UPB. E-mail-ul este de forma user_curs@stud.acs.upb.ro si poate fi accesat de la adresa http://outlook.com/upb.ro. Pentru a se activa, trebuie sa schimbati cel putin o data parola folosind platforma de cursuri (http://cs.curs.pub.ro). Activarea se va realiza in aproximativ 3 ore. E-mail-ul se acceseaza cu aceeasi parola cu cea a site-ului de cursuri.

==== 0.1. Conectarea la eduroam (1 karma WoUSO) ====

Puteți accesa internetul Wireless din facultate prin platforma [[http://eduroam.pub.ro/wiki/|eduroam]] Conectarea în rețeaua eduroam se face pe baza aceluiași cont folosit și pe site-ul de cursuri. Pentru rețeaua eduroam datele de identificare vor fi de forma:

<code bash>
utilizator eduroam: <utilizator-cursuri>@pub.ro
parola: <parola-cursuri>
</code>

unde ''<utilizator-cursuri>'' și ''<parola-cursuri>'' vor fi înlocuite cu datele de autentificare pe site-ul de cursuri http://cs.curs.pub.ro

<note important>Înainte de prima autentificare în rețeaua eduroam este nevoie ca date dvs. de conectare să fie sincronizate cu serverul de autentificare. Acest lucru se poate face printr-o schimbare a parolei în cadrul site-ului de cursuri. Puteți efectua două schimbări ale parolei, pentru a reveni la parola inițială.

**Unii dintre voi ați făcut probabil acest pas la exercițiul 0.0. sau în laboratorul 1 pentru sincronizarea cu contul de email**

Procedurile de conectare sub Linux, respectiv sub Android sunt descrise pe [[http://eduroam.pub.ro/wiki/|wiki-ul eduroam]] in linkurile de mai jos: 

  * [[http://eduroam.pub.ro/wiki/tutoriale/gnome|Eduroam Linux Gnome tutorial]]
  * [[http://eduroam.pub.ro/wiki/tutoriale/lollipop|Eduroam Android Lolliop tutorial]]

</note>
==== 1. Utilizare Git (0.5p) ====

Verificați că sunteți în directorul home al utilizatorului ''student'' (adică directorul ''/home/student''). Investigați promptul (să conțină caracterul ''~'' (tildă) pentru directorul home) sau folosiți comanda ''pwd'':

<code bash>
student@uso:~$ pwd
/home/student
</code>

Acum că știți că vă aflați în directorul home al utilizatorului ''student'', clonați conținutul [[https://github.com/systems-cs-pub-ro/uso|repository-ului oficial uso]] 

<code bash>
student@uso:~$ git clone https://github.com/systems-cs-pub-ro/uso 
</code>

<note important>
Observați că a fost creat un director numit ''uso'' în ''/home/student''. Mesajul comenzii ''git clone'' ne informează despre acest lucru (vedeți prima linie din output): 

<code bash>
Cloning into 'uso'...
remote: Counting objects: 54, done.
remote: Compressing objects: 100% (12/12), done.
remote: Total 54 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (54/54), done.
</code>

Directorul ''uso'' a fost creat **relativ** (folosind o cale relativă) la directorul curent (care în cazul nostru era ''/home/student'')

În urma comenzii de mai sus a apărut directorul ''uso'' în directorul home al utilizatorului ''student''.

<code bash>
student@uso:~$ ls
... uso ...
</code>
</note>

Folosiți comanda ''cd'' și schimbați directorul în subdirectorul ''uso/lab02''. În subdirectorul ''uso/lab02'' găsiți structura de directoare și fișierele necesare pentru rezolvarea laboratorului.

<hidden>
Celor avansati le puteti arata si:

Realizați o modificare în fișierul ''simple_math.c'' din directorul ''uso/lab02/anul_1/programare/''. Verificați stadiul modificărilor voastre: <code bash> student@uso:~$ git status </code>

Între timp, e posibil să mai fi apărut modificări în conținutul laboratorului. Avem nevoie sa ne actualizăm codul. Folosiți comanda: <code bash> student@uso:~$ git pull </code>
</hidden>

==== 2. Structura sistemului de fișiere (1p) ====

Redenumiți directorul clonat ''/home/student/uso'' în ''/home/student/uso-repository'' din linie de comandă. 

Amintiți-vă din secțiunea de demo sau din [[uso:resurse:cheatsheet|USO Cheatsheet]] cu ce comandă putem redenumi fișiere sau directoare. 

<note warning>Următoarele exerciții vor presupune că există în directorul ''/home/student'' un director numit ''uso-repository''. Asigurați-vă că sunteți în directorul corect, atenție la căi relative și absolute. Când cerința spune //Vă aflați în directorul X//, folosiți comanda ''cd X'' pentru a intra în acel director. X va fi în general o cale absolută
</note>

  * **Vă aflați în directorul ''/home/student''**.
  * Intrați în directorul ''uso-repository/lab02'', clonat la exercițiul anterior.
  * Ne dorim să vedem toate fișierele și sub-directoarele ale directorului curent. Pentru aceasta avem două opțiuni: 
      - Folosirea unui argument al comenzii ''ls'': <code bash> student@uso:~/lab02 $ ls -R </code>
      - Outputul comenzii ''**ls -R**'' nu este foarte ușor de urmărit pentru directoare cu multe intrări. Pentru a vizualiza structura arborescentă mai prietenos, putem folosi ''**tree**''. 
<note tip>E posibil ca ''tree'' să nu existe în sistem. Outputul comenzii va fi, atunci: 
<code bash>
student@uso:~/uso-repository $ tree
bash: tree: command not found...
</code>

În acest caz, e nevoie să o instalăm: 

<code bash>
student@uso:~$ sudo apt-get install tree
</code>
</note>

<solution -hidden><code>
student@uso:~$ mv /home/student/uso /home/student/uso-repository
student@uso:~$ cd uso-repository/lab02/
student@uso:~/uso-repository/lab02$ ls -R
.:
anul_1  anul_2  demo

./anul_1:
assignments.txt  mate  notite.txt  programare  uso

./anul_1/mate:
theorem1.txt  theorem2.txt

./anul_1/programare:
hello.c  simple_math.c  teme

./anul_1/programare/teme:
tema1  tema2  tema3  tema4

./anul_1/programare/teme/tema1:
hello.c  simple_math.c

./anul_1/programare/teme/tema2:
constants.c  floats.c  howto.md  inc.h  Makefile  Readme.md

./anul_1/programare/teme/tema3:
include  main.c  Makefile  src

./anul_1/programare/teme/tema3/include:
inc.h

./anul_1/programare/teme/tema3/src:
constants.c  floats.c

./anul_1/programare/teme/tema4:
include  main.c  Makefile  Readme.md  src

./anul_1/programare/teme/tema4/include:
inc.h

./anul_1/programare/teme/tema4/src:
constants.c  floats.c

./anul_1/uso:
crap.txt  empty_dir  filesys  immutable-file  not_so_empty_dir  to_delete  to_move

./anul_1/uso/empty_dir:

./anul_1/uso/filesys:

./anul_1/uso/not_so_empty_dir:
garbage.sh

./anul_1/uso/to_delete:
food.ini  junk.md

./anul_1/uso/to_move:
bula  rasela  strula

./anul_2:
cn.1  ed  eea  iocla  pa  pc  pp  ts

./demo:
ac_dc  cargo  hammerfall  iris  nightwish  phoenix  slayer

./demo/ac_dc:
angus  bon  brian  chris  cliff  dave  george  malcom  mark  phil

./demo/hammerfall:
anders  jesper  joacim  magnus  oscar  pontus  stefan
student@uso:~/uso-repository/lab02$ tree
.
├── anul_1
│   ├── assignments.txt
│   ├── mate
│   │   ├── theorem1.txt
│   │   └── theorem2.txt
│   ├── notite.txt
│   ├── programare
│   │   ├── hello.c
│   │   ├── simple_math.c
│   │   └── teme
│   │       ├── tema1
│   │       │   ├── hello.c
│   │       │   └── simple_math.c
│   │       ├── tema2
│   │       │   ├── constants.c
│   │       │   ├── floats.c
│   │       │   ├── howto.md
│   │       │   ├── inc.h
│   │       │   ├── Makefile
│   │       │   └── Readme.md
│   │       ├── tema3
│   │       │   ├── include
│   │       │   │   └── inc.h
│   │       │   ├── main.c
│   │       │   ├── Makefile
│   │       │   └── src
│   │       │       ├── constants.c
│   │       │       └── floats.c
│   │       └── tema4
│   │           ├── include
│   │           │   └── inc.h
│   │           ├── main.c
│   │           ├── Makefile
│   │           ├── Readme.md
│   │           └── src
│   │               ├── constants.c
│   │               └── floats.c
│   └── uso
│       ├── crap.txt
│       ├── empty_dir
│       ├── filesys
│       ├── immutable-file
│       ├── not_so_empty_dir
│       │   └── garbage.sh
│       ├── to_delete
│       │   ├── food.ini
│       │   └── junk.md
│       └── to_move
│           ├── bula
│           ├── rasela
│           └── strula
├── anul_2
│   ├── cn.1
│   ├── ed
│   ├── eea
│   ├── iocla
│   ├── pa
│   ├── pc
│   ├── pp
│   └── ts
└── demo
    ├── ac_dc
    │   ├── angus
    │   ├── bon
    │   ├── brian
    │   ├── chris
    │   ├── cliff
    │   ├── dave
    │   ├── george
    │   ├── malcom
    │   ├── mark
    │   └── phil
    ├── cargo
    ├── hammerfall
    │   ├── anders
    │   ├── jesper
    │   ├── joacim
    │   ├── magnus
    │   ├── oscar
    │   ├── pontus
    │   └── stefan
    ├── iris
    ├── nightwish
    ├── phoenix
    └── slayer

22 directories, 63 files
</code></solution>


==== 3. Dimensiunea fișierelor (2p) ====

Ne dorim să aflăm dimensiunile fișierelor. **Vă aflați în ''/home/student''. Intrați în directorul ''uso-repository/lab02''**

Listați conținutul detaliat al directoarelor 
<code bash> 
student@uso:~$ ls -l 
</code> 

Care coloană credeți că ne oferă informații despre dimensiune? Outputul comenzii  oferă dimensiunea în octeți (bytes) și este mai greu de citit. 

Folosiți un extra-argument al comenzii ''ls'' pentru a avea dimensiunile în format ''human-readable''. Căutați în pagina de manual a comenzii ''ls'' 

<code bash> 
student@uso:~$ man ls 
</code> 

după cuvântul cheie ''human''. Folosiți argumentul descoperit în conjuncție cu ''-l''.

Directorul ''uso-repository/lab02/anul_1/programare/teme'' conține foarte multe fișiere, de dimensiuni mari, e imposibil ca acesta să aibă doar ''4K'' dimensiune. Pentru a determina dimensiunea directoarelor, trebuie să folosim o altă comandă, ''du'' (de la disk usage). 

Iată un exemplu: 

<code bash> student@uso:~$ du uso-repository/lab02/anul_1/programare/teme 
</code> 

**Exercițiu**: determinați **doar** dimensiunea directorului ''uso-repository/lab02/anul_1/programare/teme'' (nu și a subdirectoarelor) în format human readable. Căutați în <code bash> student@uso:~$ man du </code> după cuvântul cheie ''summarize'' și identificați opțiunea (argumentul) comenzii ''du'' care vă afișează dimensiunea directorului în format sumarizat. 


<solution -hidden><code>
student@uso:~$ cd uso-repository/lab02/
student@uso:~/uso-repository/lab02$ ls -l
total 12
drwxrwxr-x 5 student student 4096 nov 20 19:33 anul_1
drwxrwxr-x 2 student student 4096 nov 20 19:33 anul_2
drwxrwxr-x 4 student student 4096 nov 20 19:33 demo
student@uso:~/uso-repository/lab02$ ls -lh
total 12K
drwxrwxr-x 5 student student 4,0K nov 20 19:33 anul_1
drwxrwxr-x 2 student student 4,0K nov 20 19:33 anul_2
drwxrwxr-x 4 student student 4,0K nov 20 19:33 demo
student@uso:~/uso-repository/lab02$ cd /home/student
student@uso:~$ du -hs uso-repository/lab02/anul_1/programare/teme/
104K	uso-repository/lab02/anul_1/programare/teme/
</code></solution>



==== 4. Ștergerea fișierelor (2p) ====

**Vă aflați în directorul ''/home/student/uso-repository''.**

Ștergeți fișierul ''crap.txt'' din directorul ''lab02/anul_1/uso''. 

Observați că am folosit o cale relativă la directorul ''/home/student''. Am fi putut folosi și 

<code bash> 
rm -f /home/student/uso-repository/lab02/anul_1/uso/crap.txt
</code>

Încercați să ștergeți directorul ''to_delete'' din ''uso''. De ce nu putem folosi comanda de mai jos, chiar dacă ea conține calea corectă, absolută? 

<code bash> 
rm -f /home/student/uso-repository/lab02/anul_1/uso/to_delete 
</code> 

Căutați în pagina de manual a ''rm'' (''man rm'') după ''recursive''. 

Intrați în directorul ''lab02/anul_1/uso''. Încercați să ștergeți directorul ''empty_dir''. Folosiți comanda 

<code bash>
rmdir empty_dir 
</code>

De ce nu putem șterge ''empty_dir'' prin această metodă? Intrați în directorul ''empty_dir'' și investigați dacă acesta conține fișiere (e posibil să conțină fișiere ascunse!). Ștergeți fișierele din el, reveniți la directorul părinte și verificați dacă funcționează comanda ''rmdir empty_dir''. 

<note tip>
Pentru a șterge un director gol putem folosi oricare din următoarele comenzi:

<code bash>
student@uso:$ cd uso-repository
student@uso:$ rm -rf lab02/anul_1/uso/empty_dir
student@uso:$ rmdir lab02/anul_1/uso/empty_dir
</code>

''rmdir'' este capabil doar să șteargă doar directoare goale. 

Verificați execuția cu succes a comenzii de ștergere folosind una de listare, de exemplu ''ls''.

</note>


<solution -hidden><code>
student@uso:~$ cd uso-repository/
student@uso:~/uso-repository$ rm lab02/anul_1/uso/crap.txt 
student@uso:~/uso-repository$ rm -rf /home/student/uso-repository/lab02/anul_1/uso/to_delete/
student@uso:~/uso-repository$ cd lab02/anul_1/uso/
student@uso:~/uso-repository/lab02/anul_1/uso$ rmdir empty_dir/
rmdir: failed to remove ‘empty_dir/’: Directory not empty
student@uso:~/uso-repository/lab02/anul_1/uso$ cd empty_dir/
student@uso:~/uso-repository/lab02/anul_1/uso/empty_dir$ ls -la
total 12
drwxrwxr-x 2 student student 4096 nov 20 19:33 .
drwxrwxr-x 6 student student 4096 nov 20 22:28 ..
-rw-rw-r-- 1 student student   37 nov 20 19:33 .keep
student@uso:~/uso-repository/lab02/anul_1/uso/empty_dir$ rm .keep 
student@uso:~/uso-repository/lab02/anul_1/uso/empty_dir$ cd ..
student@uso:~/uso-repository/lab02/anul_1/uso$ rmdir empty_dir/
</code></solution>


==== 5. Crearea unor fișiere cu denumiri complicate (2p) ====

**Intrați în directorul ''uso-repository/lab02/anul_1/uso/filesys''**

Folosiți următoarea comandă: 
<code bash> 
mkdir Program Files and Accessories 
</code> 

Listați conținutul directorului ''filesys''. Câte directoare conține acesta. De ce? A fost acesta efectul dorit? Pentru a putea crea un director cu spații în numele său avem două alternative: 

<code bash>
student@uso:$ mkdir "Program Files and Accessories"
student@uso:$ mkdir Program\ Files\ and\ Accessories
</code>

<note tip>Nu tastați comanda din nou, folosiți tasta SAGEATA_SUS pentru a reveni la comanda anterioară, tastați ''%%"%%'', ''Ctrl+A'' pentru a merge la începutul liniei, ''Alt+F'' pentru a avansa un cuvânt și, în final, tastați din nou ''"''.
</note>

Verificați că, într-adevăr, de data aceasta directorul creat are numele dorit folosind comanda ''ls''.

Fără a intra în directorul creat, ''%%"Program Files and Accessories"%%'', creați 3 fișiere cu denumirile ''%%"Open Office"%%'', ''%%"Mozilla Firefox"%%'' și ''%%"Incredible long file name that contains a lot of spaces"%%'' precum și 2 directoare cu numele ''%%"App Data"%%'' și ''%%"Local Settings"%%'' în ''%%"Program Files and Accessories"%%''. Încercați, de asemenea, să folosiți cât mai mult tasta ''TAB''.

Copiați primele două fișiere create anterior în directorul ''../../programare/'' (**atenție! e o cale relativă de la directorul ''uso-repository/lab02/anul_1/uso/filesys''**). 

Scrieți un text la întâmplare în fișierul %%"Incredible long file name that contains a lot of spaces"%% folosind comanda ''echo'' sau ''vim''.

<code bash>
student@uso:$ echo "un text" > Inc<TAB>   # folosiți neapărat tasta TAB, nu tastați tot numele fișierului
</code>

Redenumiți fișierul ''%%"Incredible long file name that contains a lot of spaces"%%'' în ''%%"Incredible long file name that contains less spaces"%%''. Abuzați de tasta ''TAB''. Încercați să folosiți cât mai puține taste.

<note tip>Un mod rapid de rezolvare poate fi următorul. Tastăm ''mv'' urmat de combinația ''Alt+.'' , ''SPACE'' și iarăși ''Alt+.'' (combinația de taste ''Alt+.'' este o modalitate de a itera prin ultimii parametri ai comenzilor anterioare). Tastăm apoi ''Alt+b'' pentru a merge un cuvânt înapoi după care, folosind ''Alt+Backspace'', ștergem cele 3 cuvinte care nu ne mai trebuie. În final, nu rămâne decât de adăugat textul %%"less\ "%%.
</note>

Copiați întregul director ''filesys'' în ''/home/student''. De ce nu funcționează comanda de mai jos?

<code bash>
student@uso:$ pwd
/home/student/uso-repository/lab02/anul_1/uso/filesys
student@uso:$ cp . /home/student
</code>

Avem nevoie de ''recursive'' (ca la ''rm''). Căutați în pagina de manual a ''cp'' (''man cp'') după ''recursive''.

Intrați în directorul părinte lui ''filesys''. Mutați directorul ''to_move'' în ''/tmp''. Observați că pentru ''mv'' nu avem nevoie de parametrul ''-r'' (pentru recursivitate). 

Verificați execuția cu success a comenzii folosind o comandă ''ls''.



<solution -hidden><code>
student@uso:~$ cd uso-repository/lab02/anul_1/uso/filesys/
student@uso:~/uso-repository/lab02/anul_1/uso/filesys$ mkdir "Program Files and Accessories"
student@uso:~/uso-repository/lab02/anul_1/uso/filesys$ cd Program\ Files\ and\ Accessories/
student@uso:~/uso-repository/lab02/anul_1/uso/filesys/Program Files and Accessories$ touch fisier1
student@uso:~/uso-repository/lab02/anul_1/uso/filesys/Program Files and Accessories$ touch "fisier 2"
student@uso:~/uso-repository/lab02/anul_1/uso/filesys/Program Files and Accessories$ touch fisier\ 3
student@uso:~/uso-repository/lab02/anul_1/uso/filesys/Program Files and Accessories$ mkdir file
student@uso:~/uso-repository/lab02/anul_1/uso/filesys/Program Files and Accessories$ mkdir "file (1)"
student@uso:~/uso-repository/lab02/anul_1/uso/filesys/Program Files and Accessories$ ls -l
total 8
drwxrwxr-x 2 student student 4096 nov 20 22:33 file
drwxrwxr-x 2 student student 4096 nov 20 22:33 file (1)
-rw-rw-r-- 1 student student    0 nov 20 22:32 fisier1
-rw-rw-r-- 1 student student    0 nov 20 22:32 fisier 2
-rw-rw-r-- 1 student student    0 nov 20 22:33 fisier 3
student@uso:~/uso-repository/lab02/anul_1/uso/filesys/Program Files and Accessories$ cp fisier1 fisier\ 2 ../../../programare/
student@uso:~/uso-repository/lab02/anul_1/uso/filesys/Program Files and Accessories$ cd ..
student@uso:~/uso-repository/lab02/anul_1/uso/filesys$ cp -r . /home/student/
student@uso:~/uso-repository/lab02/anul_1/uso/filesys$ cd ..
student@uso:~/uso-repository/lab02/anul_1/uso$ mv to_move/ /tmp
</code></solution>


==== 6. Vimtutor (1p) ====
De multe ori suntem nevoiți să edităm fișiere direct în linia de comandă, fără ajutorul interfeței grafice (ex. atunci când suntem logați pe un server printr-o sesiune la distanță, **așa cum vom avea la examenul practic**). Unul dintre cele mai populare editoare în linia de comandă este ''vim''. Pe parcursul semestrului veți întâlni de multe ori în cadrul laboratorului de USO (și nu numai) mențiuni către ''vim'' și, de asemenea, este foarte probabil ca la testele practice sau examenul final să fiți nevoiți să-l folosiți datorită lipsei unei interfețe grafice instalate.

Pentru a ușura procesul de învățare a comenzilor de bază în ''vim'', există ''vimtutor'', un tutorial foarte pe larg în linie de comandă. Porniți ''vimtutor'' folosind comanda cu același nume
<code bash>
student@uso:~$ vimtutor
</code>
și **parcurgeți primele 3 lecții de acolo**. 

<note warning>Citiți cu atenție tot textul, parcurgeți-l linie cu linie fără a sări peste anumite lucruri. Chemați asistentul ori de câte ori vi se pare că nu înțelegeți ceva.</note>

<note>Pentru mai multe detalii despre utilizarea ''vim'' puteți consulta [[uso:resurse:folosire-vim|Vim Cheatsheet]]. În general când lucrați cu Vim, dacă vă loviți de probleme, apăsați ''ESC'' pentru a ajunge în modul normal. Și rețineți că puteți folosi, în modul normal, comanda '':q!'' pentru a părăsi editorul fără a salva vreo modificare.
</note>

==== 7. Căi relative vs. căi absolute (1p) ====
Mergeți în directorul ''/home/student/uso-repository/lab02/anul_1''. Folosiți cât mai mult tasta ''TAB'' pentru a ajunge aici.

<code bash>
student@uso:~$ cd /home/st<TAB>/uso<TAB>/lab02/a<TAB>_1
</code>

Folosiți comanda ''tree'' pentru a investiga structura de directoare și fișiere din directorul curent. Mergeți apoi în directorul ''programare/teme'' folosind o cale relativă:
<code bash>
student@uso:~$ cd programare/teme
</code>
Verificați că vă aflați în directorul dorit folosind comanda ''pwd''.

Fără a schimba directorul curent, deci fără a utiliza vreo comandă ''cd'' creați câte un fișier cu numele ''TODO'' în folderele ''uso'', respectiv ''programare'' din directorul ''anul_1''. Folosiți căi relative. Spre exemplu, pentru directorul programare putem proceda în felul următor:
<code bash>
student@uso:$ touch ../TODO
</code>
Realizați același lucru pentru directorul ''uso''. 

Mergeți acum tot în directorul ''uso'' folosind de data aceasta o cale absolută (trebuie să înceapă cu ''/'' sau ''~''). Editați fișierul ''TODO'' creat anterior folosind editorul ''vim'' astfel încât la final să conțină textul %%"O sa iau nota 10 la USO"%%.

Verificați faptul că fișierul conține textul dorit folosind comanda ''cat'' care afișează conținutul fișierului pe ecran.

Copiați fișierul ''TODO'' din directorul ''uso'' peste cel din directorul ''programare''. Încercați să folosiți cât mai puține taste și doar căi relative.
===== BONUS =====

==== 1. Crearea arhivelor zip/tar (1 karma WoUSO) ====

**[1a]** Intrați în directorul ''uso-repository/lab02/anul_1/programare/teme/tema1''. Folosind interfața grafică, creați o arhivă ''.zip'' care conține toate fișierele cu extensia ''.c'', **în rădăcina arhivei**.

**[1b]** Intrați în directorul ''uso-repository/lab02/anul_1/programare/teme/tema2''. Folosind linia de comandă, creați o arhivă ''.zip'' care conține toate fișierele cu extensia ''.c'', ''.h'', ''.md'', ''Makefile'', **în rădăcina arhivei**. Folosiți comanda ''zip''. Consultați [[http://www.linuxnix.com/linuxunix-zip-and-unzip-command-examples/|această pagină]] pentru exemple de utilizare.

<solution -hidden><code>
student@uso:~$ cd uso-repository/lab02/anul_1/programare/teme/tema2
student@uso:~/uso-repository/lab02/anul_1/programare/teme/tema2$ ls
constants.c  floats.c  howto.md  inc.h  Makefile  Readme.md
student@uso:~/uso-repository/lab02/anul_1/programare/teme/tema2$ zip tema2.zip *.c *.h *.md Makefile 
  adding: constants.c (deflated 31%)
  adding: floats.c (deflated 32%)
  adding: inc.h (deflated 24%)
  adding: howto.md (deflated 18%)
  adding: Readme.md (deflated 12%)
  adding: Makefile (deflated 36%)
student@uso:~/uso-repository/lab02/anul_1/programare/teme/tema2$ unzip -l tema2.zip 
Archive:  tema2.zip
  Length      Date    Time    Name
---------  ---------- -----   ----
      198  2014-11-20 19:33   constants.c
      204  2014-11-20 19:33   floats.c
      122  2014-11-20 19:33   inc.h
       98  2014-11-20 19:33   howto.md
       43  2014-11-20 19:33   Readme.md
       73  2014-11-20 19:33   Makefile
---------                     -------
      738                     6 files
</code></solution>

**[1c]** Intrați în directorul ''uso-repository/lab02/anul_1/programare/teme''. Folosind linia de comandă, creați o arhivă ''.tar.gz'' care conține **în rădăcina arhivei** directorul ''tema3''. Pentru aceasta nu mai putem folosi comanda ''zip'', ci putem, de exemplu, utiliza comanda ''tar''. Spre deosebire de ''zip'', ''tar'' poate lucra cu mai multe tipuri de compresie, prin urmare va trebui să-i specificați printr-un parametru că doriți o arhivă de tipul ''gzip''. Căutați după stringul ''gzip'' în pagina de manual a comenzii ''tar''. 

<code bash>
student@uso:~$ man tar
</code>

De asemenea, pentru a specifica faptul că dorim crearea unei arhive precum și numele acesteia, sunt necesari alți doi parametri pentru comanda ''tar''. Căutați în pagina de manual după strigurile ''create'', respectiv ''filename''. Consultați [[http://www.thegeekstuff.com/2010/04/unix-tar-command-examples/|această pagină]] pentru mai multe exemple de utilizare a comenzii ''tar''.

<code bash>
student@uso:~$ student@uso:~$ cd uso-repository/lab02/anul_1/programare/teme/
student@uso:~$ student@uso:~$ tar -czvf tema3.tar.gz tema3/
</code>


==== 2. Wildcards (1 karma WoUSO) ====
Am văzut în secțiunea de Demo că putem folosi anumite caractere ce țin locul unor bucăți de text, de exemplu caracterul ''*''. De exemplu, dacă dorim să listăm toate fișierele din ''/etc'' care încep cu stringul ''ssh'' putem folosi comanda:

<code bash>
student@uso:~$ ls /etc/ssh*
</code>

După cum observați, caracterul ''*'' ține loc pentru %%"oricâte și orice caractere"%%. Procedați asemănător și afișați fișierele sau directoarele din ''/etc'' cu extensia ''.conf''. 

Realizați o arhivă de tipul ''zip'' în directorul ''home'' al utilizatorului ''student'' (''/home/student'') care să conțină toate fișierele și directoarele din ''/etc/'' care conțin stringul ''conf'' în numele lor.

<note tip>Este foarte probabil ca printre fișierele și directoarele găsite să existe directoare care nu sunt goale. Pentru a arhiva și conținutul acestora trebuie să specificăm acest lucru explicit comenzii ''zip''. Căutați în pagina de manual după stringul ''recursive''.</note>

<hidden>
<solution -hidden>
<code bash>
student@uso:~$ zip -r /etc/*conf*
</code>
</solution>
</hidden>
==== 3. Căutarea în sistemul de fișiere (1 karma WoUSO) ====
De multe ori se întâmplă să vrem să accesăm un anumit fișier sau director, dar nu cunoaștem calea exactă către el sau pur și simplu nu mai cunoaștem nici numele exact al fișierului ci numai o mică parte. Pentru a realiza o căutare foarte rapidă în tot sistemul de fișiere putem folosi comanda ''locate''.

<code bash>
stdudent@uso:~$ locate vmlinuz
</code>

Creați acum un fișier în directorul ''/home/student/uso-repository'' cu numele ''uso-file''. Căutați fișierul folosind comanda ''locate''. Observăm că de această dată comanda ''locate'' nu mai găsește niciun fișier, chiar dacă suntem siguri că el există. Acest lucru se datorează faptului că ''locate'' realizează o căutare indexată pe baza unei baze de date proprii. Din cauza faptului că baza de date nu a fost actualizată recent, fișierul creat de noi nu este indexat. Căutați în pagina de manual a comenzii ''locate'' cum putem aduce la zi baza de date. Căutați din nou fișierul ''uso-file''.

De notat faptul că locate acceptă și wildcards, prin urmare putem căuta, de exemplu, fișiere cărora nu le cunoaștem numele complet.

<code bash>
student@uso:~$ locate *linuz
</code>
==== 4. Istoria directoarelor prin care am navigat (2 karma WoUSO) ====

  * Reamintiți-vă ce face comanda ''cd -''. 
  * Identificați o problemă a ei. 
  * Ce se întâmplă dacă o folosim de două ori consecutiv?
  * Explicați funcționarea comenzilor ''pushd'' și ''popd''. 
  * Cum putem afișa stiva de directoare, fără a o modifica? Indicație: ''dirs''.
  * ''pushd'', ''popd'' și ''dirs'' sunt comenzi built-in ale shell-ului (Bash). Drept urmare, nu au propria pagină de manual. Căutați informații despre ele în ''man bash''.
  * Navigați prin folderul ''uso-repository/lab02'' folosind ''pushd'' și ''popd'' (afișați din când în când stiva de directoare)

<hidden>
<solution -hidden>
<code bash>
student@uso:$ cd ~
student@uso:$ pushd uso-repository
student@uso:$ pushd lab02
student@uso:$ pwd
/home/student/uso-repository/lab02
student@uso:$ dirs
~/uso-repository/lab02 ~/uso-repository ~
student@uso:$ popd
student@uso:$ pwd
/home/student/uso-repository/
</code>
</solution>
</hidden>
===== Sumar. Cuvinte cheie =====

  * Version Control: Git, ''git''.
  * Navigare prin directoare: ''cd''. Listarea conținutului: ''ls''. Sistemul de fișiere în Linux are o structură arborescentă: ''ls -R'', ''tree''
  * Redenumire fișiere, mutare fișiere: ''mv''
  * Copiere fișiere: ''cp''
  * Linux manpages and offline help: ''man'', ''apropos'', ''which'', ''whereis''
  * Wildcard listing use-case: Listarea tuturor fișierelor cu extensia ''.conf'' din directorul ''etc'' din rădăcină: <code bash> ls /etc/*.conf </code>
  * Informații despre spațiul ocupat pe disk: ''ls -l'' vs. ''du''
  * Copiere/ștergere recursivă a directoarelor care nu sunt goale: ''rm -r my_dir'', ''cp -R my_dir''
  * ''rmdir'' vs. ''rm'' vs. ''rm -rf''
  * Afișarea conținutului unor fișiere: ''cat file''. Semnificația ''cat'' este de concatenare a fișierelr primite ca argument de intrare și de afișare la ieșirea standard a conținutului: ''cat file1 file2 file3 ... ''. Dacă nici un fișier nu e dat ca argument de intrare, atunci ''cat'' va aștepta date de la intrarea standard (tastatură) până când este apăsata combinația de taste ''CTRL+d''.
  * Istoricul comenzilor executate: ''history'', sau mai eficient: reverse search, folosind combinația de taste ''CTRL+r''
  * Căutarea în sistemul de fișiere: ''locate''
  * Editarea de fișiere text: ''vim''. Tutorial pentru ''vim'': comanda ''vimtutor''.
  * Arhivare/dezarhivare: ''tar'', ''zip''